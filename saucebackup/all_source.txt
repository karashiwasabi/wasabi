----- C:\Dev\WASABI\aggregation\handler.go -----
package aggregation

import (
	"database/sql"
	"encoding/json"
	"net/http"
	"strconv"
	"strings"
	"wasabi/db"
	"wasabi/model"
)

// GetAggregationHandler handles the request for the stock ledger report.
func GetAggregationHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		q := r.URL.Query()

		coefficient, err := strconv.ParseFloat(q.Get("coefficient"), 64)
		if err != nil {
			coefficient = 1.5 // Default value
		}

		// 新しいフィルター条件を構造体に含める
		filters := model.AggregationFilters{
			StartDate:   q.Get("startDate"),
			EndDate:     q.Get("endDate"),
			KanaName:    q.Get("kanaName"),
			DrugTypes:   strings.Split(q.Get("drugTypes"), ","),
			DosageForm:  q.Get("dosageForm"), // 剤型を取得
			Coefficient: coefficient,
		}

		results, err := db.GetStockLedger(conn, filters)
		if err != nil {
			http.Error(w, "Failed to get aggregated data: "+err.Error(), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(results)
	}
}


----- C:\Dev\WASABI\backup\handler.go -----
package backup

import (
	"database/sql"
	"encoding/csv"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"wasabi/db"
	"wasabi/model"
)

// ExportClientsHandler handles exporting the client master to a CSV file.
func ExportClientsHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		clients, err := db.GetAllClients(conn)
		if err != nil {
			http.Error(w, "Failed to get clients", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "text/csv; charset=utf-8")
		w.Header().Set("Content-Disposition", `attachment; filename="client_master.csv"`)
		w.Write([]byte{0xEF, 0xBB, 0xBF})

		csvWriter := csv.NewWriter(w)

		if err := csvWriter.Write([]string{"client_code", "client_name"}); err != nil {
			http.Error(w, "Failed to write CSV header", http.StatusInternalServerError)
			return
		}
		for _, client := range clients {
			if err := csvWriter.Write([]string{client.Code, client.Name}); err != nil {
				http.Error(w, "Failed to write CSV row", http.StatusInternalServerError)
				return
			}
		}
		csvWriter.Flush()
	}
}

// ImportClientsHandler handles importing clients from a CSV file.
func ImportClientsHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		file, _, err := r.FormFile("file")
		if err != nil {
			http.Error(w, "No file uploaded", http.StatusBadRequest)
			return
		}
		defer file.Close()

		csvReader := csv.NewReader(file)
		records, err := csvReader.ReadAll()
		if err != nil {
			http.Error(w, "Failed to parse CSV file", http.StatusBadRequest)
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		stmt, err := tx.Prepare("INSERT OR REPLACE INTO client_master (client_code, client_name) VALUES (?, ?)")
		if err != nil {
			http.Error(w, "Failed to prepare DB statement", http.StatusInternalServerError)
			return
		}
		defer stmt.Close()

		var importedCount int
		for i, row := range records {
			if i == 0 {
				continue
			}
			if len(row) < 2 {
				continue
			}
			if _, err := stmt.Exec(row[0], row[1]); err != nil {
				log.Printf("Failed to import client row %d: %v", i+1, err)
				http.Error(w, fmt.Sprintf("Failed to import client row %d", i+1), http.StatusInternalServerError)
				return
			}
			importedCount++
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}
		if err := db.InitializeSequenceFromMaxClientCode(conn); err != nil {
			log.Printf("Warning: failed to re-initialize client sequence after import: %v", err)
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"message": fmt.Sprintf("%d件の得意先をインポートしました。", importedCount),
		})
	}
}

// ExportProductsHandler handles exporting the product master to a CSV file.
func ExportProductsHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// ▼▼▼ [修正点] 全件取得ではなく、編集可能なマスターのみを取得する関数に変更 ▼▼▼
		products, err := db.GetEditableProductMasters(conn)
		if err != nil {
			http.Error(w, "Failed to get products", http.StatusInternalServerError)
			return
		}
		// ▲▲▲ 修正ここまで ▲▲▲

		w.Header().Set("Content-Type", "text/csv; charset=utf-8")
		w.Header().Set("Content-Disposition", `attachment; filename="product_master_editable.csv"`)
		w.Write([]byte{0xEF, 0xBB, 0xBF}) // UTF-8 BOM

		csvWriter := csv.NewWriter(w)

		header := []string{
			"product_code", "yj_code", "product_name", "origin", "kana_name", "maker_name",
			"usage_classification", "package_form", "package_spec",
			"yj_unit_name", "yj_pack_unit_qty", "flag_poison", "flag_deleterious", "flag_narcotic",
			"flag_psychotropic", "flag_stimulant", "flag_stimulant_raw", "jan_pack_inner_qty",
			"jan_unit_code", "jan_pack_unit_qty", "nhi_price", "purchase_price", "supplier_wholesale",
		}
		if err := csvWriter.Write(header); err != nil {
			http.Error(w, "Failed to write CSV header", http.StatusInternalServerError)
			return
		}

		// `GetEditableProductMasters`は`ProductMasterView`のスライスを返すため、
		// `p.ProductMaster`を通じて各フィールドにアクセスするか、そのままアクセスする（Goの埋め込みのため）
		for _, p := range products {
			row := []string{
				p.ProductCode, p.YjCode, p.ProductName, p.Origin, p.KanaName, p.MakerName,
				p.UsageClassification, p.PackageForm, p.PackageSpec,
				p.YjUnitName, fmt.Sprintf("%f", p.YjPackUnitQty), fmt.Sprintf("%d", p.FlagPoison),
				fmt.Sprintf("%d", p.FlagDeleterious), fmt.Sprintf("%d", p.FlagNarcotic),
				fmt.Sprintf("%d", p.FlagPsychotropic), fmt.Sprintf("%d", p.FlagStimulant),
				fmt.Sprintf("%d", p.FlagStimulantRaw), fmt.Sprintf("%f", p.JanPackInnerQty),
				fmt.Sprintf("%d", p.JanUnitCode), fmt.Sprintf("%f", p.JanPackUnitQty),
				fmt.Sprintf("%f", p.NhiPrice), fmt.Sprintf("%f", p.PurchasePrice), p.SupplierWholesale,
			}
			if err := csvWriter.Write(row); err != nil {
				http.Error(w, "Failed to write CSV row", http.StatusInternalServerError)
				return
			}
		}
		csvWriter.Flush()
	}
}

// ImportProductsHandler handles importing products from a CSV file.
func ImportProductsHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		file, _, err := r.FormFile("file")
		if err != nil {
			http.Error(w, "No file uploaded", http.StatusBadRequest)
			return
		}
		defer file.Close()

		csvReader := csv.NewReader(file)
		records, err := csvReader.ReadAll()
		if err != nil {
			http.Error(w, "Failed to parse CSV file", http.StatusBadRequest)
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		var importedCount int
		for i, row := range records {
			if i == 0 {
				continue
			}
			if len(row) < 23 {
				continue
			}

			yjPackUnitQty, _ := strconv.ParseFloat(row[10], 64)
			flagPoison, _ := strconv.Atoi(row[11])
			flagDeleterious, _ := strconv.Atoi(row[12])
			flagNarcotic, _ := strconv.Atoi(row[13])
			flagPsychotropic, _ := strconv.Atoi(row[14])
			flagStimulant, _ := strconv.Atoi(row[15])
			flagStimulantRaw, _ := strconv.Atoi(row[16])
			janPackInnerQty, _ := strconv.ParseFloat(row[17], 64)
			janUnitCode, _ := strconv.Atoi(row[18])
			janPackUnitQty, _ := strconv.ParseFloat(row[19], 64)
			nhiPrice, _ := strconv.ParseFloat(row[20], 64)
			purchasePrice, _ := strconv.ParseFloat(row[21], 64)

			input := model.ProductMasterInput{
				ProductCode: row[0], YjCode: row[1], ProductName: row[2], Origin: row[3], KanaName: row[4],
				MakerName: row[5], UsageClassification: row[6], PackageForm: row[7], PackageSpec: row[8],
				YjUnitName: row[9], YjPackUnitQty: yjPackUnitQty, FlagPoison: flagPoison,
				FlagDeleterious: flagDeleterious, FlagNarcotic: flagNarcotic, FlagPsychotropic: flagPsychotropic,
				FlagStimulant: flagStimulant, FlagStimulantRaw: flagStimulantRaw,
				JanPackInnerQty: janPackInnerQty, JanUnitCode: janUnitCode, JanPackUnitQty: janPackUnitQty,
				NhiPrice: nhiPrice, PurchasePrice: purchasePrice, SupplierWholesale: row[22],
			}

			if err := db.UpsertProductMasterInTx(tx, input); err != nil {
				log.Printf("Failed to import product row %d: %v", i+1, err)
				http.Error(w, fmt.Sprintf("Failed to import product row %d", i+1), http.StatusInternalServerError)
				return
			}
			importedCount++
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		if err := db.InitializeSequenceFromMaxYjCode(conn); err != nil {
			log.Printf("Warning: failed to re-initialize YJ sequence after import: %v", err)
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"message": fmt.Sprintf("%d件の製品をインポートしました。", importedCount),
		})
	}
}


----- C:\Dev\WASABI\config\config.go -----
// C:\Dev\WASABI\config\config.go

package config

import (
	"encoding/json"
	"os"
	"sync"
)

type Config struct {
	EmednetUserID   string `json:"emednetUserId"`
	EmednetPassword string `json:"emednetPassword"`
}

var (
	cfg Config
	mu  sync.RWMutex
)

const configFilePath = "./config.json"

func LoadConfig() (Config, error) {
	mu.RLock()
	defer mu.RUnlock()

	file, err := os.ReadFile(configFilePath)
	if err != nil {
		if os.IsNotExist(err) {
			return Config{}, nil
		}
		return Config{}, err
	}

	var tempCfg Config
	if err := json.Unmarshal(file, &tempCfg); err != nil {
		return Config{}, err
	}
	cfg = tempCfg
	return cfg, nil
}

func SaveConfig(newCfg Config) error {
	mu.Lock()
	defer mu.Unlock()

	file, err := json.MarshalIndent(newCfg, "", "  ")
	if err != nil {
		return err
	}

	if err := os.WriteFile(configFilePath, file, 0644); err != nil {
		return err
	}
	cfg = newCfg
	return nil
}

func GetConfig() Config {
	mu.RLock()
	defer mu.RUnlock()
	return cfg
}


----- C:\Dev\WASABI\dat\handler.go -----
// C:\Dev\WASABI\dat\handler.go

package dat

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"wasabi/db"
	"wasabi/mappers"
	"wasabi/mastermanager"
	"wasabi/model"
	"wasabi/parsers"
)

// insertTransactionQuery defines the SQL statement for inserting transaction records.
const insertTransactionQuery = `
INSERT OR REPLACE INTO transaction_records (
    transaction_date, client_code, receipt_number, line_number, flag,
    jan_code, yj_code, product_name, kana_name, usage_classification, package_form, package_spec, maker_name,
    dat_quantity, jan_pack_inner_qty, jan_quantity, jan_pack_unit_qty, jan_unit_name, jan_unit_code,
    yj_quantity, yj_pack_unit_qty, yj_unit_name, unit_price, purchase_price, supplier_wholesale,
    subtotal, tax_amount, tax_rate, expiry_date, lot_number, flag_poison,
    flag_deleterious, flag_narcotic, flag_psychotropic, flag_stimulant,
    flag_stimulant_raw, process_flag_ma, processing_status
) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)`

// UploadDatHandler はDATファイルのアップロードを処理します。
func UploadDatHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var originalJournalMode string
		conn.QueryRow("PRAGMA journal_mode").Scan(&originalJournalMode)

		conn.Exec("PRAGMA journal_mode = MEMORY;")
		conn.Exec("PRAGMA synchronous = OFF;")

		defer func() {
			conn.Exec("PRAGMA synchronous = FULL;")
			conn.Exec(fmt.Sprintf("PRAGMA journal_mode = %s;", originalJournalMode))
			log.Println("Database settings restored for DAT handler.")
		}()

		if err := r.ParseMultipartForm(32 << 20); err != nil {
			http.Error(w, "File upload error: "+err.Error(), http.StatusBadRequest)
			return
		}
		defer r.MultipartForm.RemoveAll()

		var allParsedRecords []model.UnifiedInputRecord
		for _, fileHeader := range r.MultipartForm.File["file"] {
			file, err := fileHeader.Open()
			if err != nil {
				log.Printf("Failed to open file %s: %v", fileHeader.Filename, err)
				continue
			}
			defer file.Close()
			parsed, err := parsers.ParseDat(file)
			if err != nil {
				log.Printf("Failed to parse file %s: %v", fileHeader.Filename, err)
				continue
			}
			allParsedRecords = append(allParsedRecords, parsed...)
		}

		filteredRecords := removeDatDuplicates(allParsedRecords)

		if len(filteredRecords) == 0 {
			w.Header().Set("Content-Type", "application/json; charset=utf-8")
			json.NewEncoder(w).Encode(map[string]interface{}{
				"message": "No new records to process.",
				"records": []model.TransactionRecord{},
			})
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to begin transaction", http.StatusInternalServerError)
			return
		}

		var keyList, janList []string
		keySet, janSet := make(map[string]struct{}), make(map[string]struct{})
		for _, rec := range filteredRecords {
			if rec.JanCode != "" && rec.JanCode != "0000000000000" {
				if _, seen := janSet[rec.JanCode]; !seen {
					janSet[rec.JanCode] = struct{}{}
					janList = append(janList, rec.JanCode)
				}
			}
			key := rec.JanCode
			if key == "" || key == "0000000000000" {
				key = fmt.Sprintf("9999999999999%s", rec.ProductName)
			}
			if _, seen := keySet[key]; !seen {
				keySet[key] = struct{}{}
				keyList = append(keyList, key)
			}
		}

		// ▼▼▼ [修正点] マスター取得をコネクション(conn)ではなくトランザクション(tx)で行う ▼▼▼
		mastersMap, err := db.GetProductMastersByCodesMap(tx, keyList)
		if err != nil {
			tx.Rollback()
			http.Error(w, "Failed to pre-fetch product masters", http.StatusInternalServerError)
			return
		}
		jcshmsMap, err := db.GetJcshmsByCodesMap(tx, janList)
		if err != nil {
			tx.Rollback()
			http.Error(w, "Failed to pre-fetch JCSHMS data", http.StatusInternalServerError)
			return
		}
		// ▲▲▲ 修正ここまで ▲▲▲

		stmt, err := tx.Prepare(insertTransactionQuery)
		if err != nil {
			tx.Rollback()
			http.Error(w, "Failed to prepare statement", http.StatusInternalServerError)
			return
		}
		defer stmt.Close()

		const batchSize = 500
		var finalRecords []model.TransactionRecord

		for i, rec := range filteredRecords {
			ar := model.TransactionRecord{
				TransactionDate: rec.Date, ClientCode: rec.ClientCode, ReceiptNumber: rec.ReceiptNumber,
				LineNumber: rec.LineNumber, Flag: rec.Flag, JanCode: rec.JanCode,
				ProductName: rec.ProductName, DatQuantity: rec.DatQuantity, UnitPrice: rec.UnitPrice,
				Subtotal: rec.Subtotal, ExpiryDate: rec.ExpiryDate, LotNumber: rec.LotNumber,
			}

			master, err := mastermanager.FindOrCreate(tx, rec.JanCode, rec.ProductName, mastersMap, jcshmsMap)
			if err != nil {
				tx.Rollback()
				http.Error(w, fmt.Sprintf("mastermanager failed for jan %s: %v", rec.JanCode, err), http.StatusInternalServerError)
				return
			}

			if master.JanPackUnitQty > 0 {
				ar.JanQuantity = ar.DatQuantity * master.JanPackUnitQty
			}
			if master.YjPackUnitQty > 0 {
				ar.YjQuantity = ar.DatQuantity * master.YjPackUnitQty
			}
			mappers.MapProductMasterToTransaction(&ar, master)

			if master.Origin == "JCSHMS" {
				ar.ProcessFlagMA = "COMPLETE"
				ar.ProcessingStatus = sql.NullString{String: "completed", Valid: true}
			} else {
				ar.ProcessFlagMA = "PROVISIONAL"
				ar.ProcessingStatus = sql.NullString{String: "provisional", Valid: true}
			}

			_, err = stmt.Exec(
				ar.TransactionDate, ar.ClientCode, ar.ReceiptNumber, ar.LineNumber, ar.Flag,
				ar.JanCode, ar.YjCode, ar.ProductName, ar.KanaName, ar.UsageClassification, ar.PackageForm, ar.PackageSpec, ar.MakerName,
				ar.DatQuantity, ar.JanPackInnerQty, ar.JanQuantity, ar.JanPackUnitQty, ar.JanUnitName, ar.JanUnitCode,
				ar.YjQuantity, ar.YjPackUnitQty, ar.YjUnitName, ar.UnitPrice, ar.PurchasePrice, ar.SupplierWholesale,
				ar.Subtotal, ar.TaxAmount, ar.TaxRate, ar.ExpiryDate, ar.LotNumber, ar.FlagPoison,
				ar.FlagDeleterious, ar.FlagNarcotic, ar.FlagPsychotropic, ar.FlagStimulant,
				ar.FlagStimulantRaw, ar.ProcessFlagMA, ar.ProcessingStatus,
			)
			if err != nil {
				tx.Rollback()
				http.Error(w, fmt.Sprintf("Failed to insert record for JAN %s: %v", ar.JanCode, err), http.StatusInternalServerError)
				return
			}

			finalRecords = append(finalRecords, ar)

			if (i+1)%batchSize == 0 && i < len(filteredRecords)-1 {
				if err := tx.Commit(); err != nil {
					log.Printf("transaction commit error (batch): %v", err)
					http.Error(w, "internal server error", http.StatusInternalServerError)
					return
				}
				tx, err = conn.Begin()
				if err != nil {
					http.Error(w, "Failed to begin next transaction", http.StatusInternalServerError)
					return
				}
				stmt, err = tx.Prepare(insertTransactionQuery)
				if err != nil {
					tx.Rollback()
					http.Error(w, "Failed to re-prepare statement", http.StatusInternalServerError)
					return
				}
			}
		}

		if err := tx.Commit(); err != nil {
			log.Printf("transaction commit error (final): %v", err)
			http.Error(w, "internal server error", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"message": "Parsed and processed DAT files successfully",
			"records": finalRecords,
		})
	}
}

func removeDatDuplicates(records []model.UnifiedInputRecord) []model.UnifiedInputRecord {
	seen := make(map[string]struct{})
	var result []model.UnifiedInputRecord
	for _, r := range records {
		key := fmt.Sprintf("%s|%s|%s|%s", r.Date, r.ClientCode, r.ReceiptNumber, r.LineNumber)
		if _, ok := seen[key]; ok {
			continue
		}
		seen[key] = struct{}{}
		result = append(result, r)
	}
	return result
}


----- C:\Dev\WASABI\db\aggregation.go -----
// C:\Dev\WASABI\db\aggregation.go

package db

import (
	"database/sql"
	"fmt"
	"sort"
	"strings"
	"wasabi/model"
	"wasabi/units"
)

// GetStockLedger generates the stock ledger report with the new, simplified calculation logic.
func GetStockLedger(conn *sql.DB, filters model.AggregationFilters) ([]model.StockLedgerYJGroup, error) {
	masterQuery := `SELECT ` + selectColumns + ` FROM product_master p WHERE 1=1 `
	var masterArgs []interface{}
	if filters.KanaName != "" {
		masterQuery += " AND p.kana_name LIKE ? "
		masterArgs = append(masterArgs, "%"+filters.KanaName+"%")
	}
	if filters.DosageForm != "" {
		// 【修正点】検索対象を package_form から usage_classification に変更
		masterQuery += " AND p.usage_classification LIKE ? "
		masterArgs = append(masterArgs, "%"+filters.DosageForm+"%")
	}
	if len(filters.DrugTypes) > 0 && filters.DrugTypes[0] != "" {
		var conditions []string
		flagMap := map[string]string{
			"poison": "p.flag_poison = 1", "deleterious": "p.flag_deleterious = 1", "narcotic": "p.flag_narcotic = 1",
			"psychotropic1": "p.flag_psychotropic = 1", "psychotropic2": "p.flag_psychotropic = 2", "psychotropic3": "p.flag_psychotropic = 3",
			"stimulant": "p.flag_stimulant = 1", "stimulant_raw": "p.flag_stimulant_raw = 1",
		}
		for _, dt := range filters.DrugTypes {
			if cond, ok := flagMap[dt]; ok {
				conditions = append(conditions, cond)
			}
		}
		if len(conditions) > 0 {
			masterQuery += " AND (" + strings.Join(conditions, " OR ") + ")"
		}
	}

	masterRows, err := conn.Query(masterQuery, masterArgs...)
	if err != nil {
		return nil, err
	}
	defer masterRows.Close()

	mastersByYjCode := make(map[string][]*model.ProductMaster)
	var productCodes []string
	for masterRows.Next() {
		m, err := scanProductMaster(masterRows)
		if err != nil {
			return nil, err
		}
		if m.YjCode != "" {
			mastersByYjCode[m.YjCode] = append(mastersByYjCode[m.YjCode], m)
		}
		productCodes = append(productCodes, m.ProductCode)
	}
	if len(productCodes) == 0 {
		return []model.StockLedgerYJGroup{}, nil
	}

	var txArgs []interface{}
	for _, pc := range productCodes {
		txArgs = append(txArgs, pc)
	}

	transactionsByProductCode := make(map[string][]*model.TransactionRecord)
	if len(productCodes) > 0 {
		txQuery := `SELECT ` + TransactionColumns + ` FROM transaction_records WHERE jan_code IN (?` + strings.Repeat(",?", len(productCodes)-1) + `) AND transaction_date >= ? AND transaction_date <= ? ORDER BY transaction_date, id`
		txArgsWithDate := append(txArgs, filters.StartDate, filters.EndDate)

		txRows, err := conn.Query(txQuery, txArgsWithDate...)
		if err != nil {
			return nil, err
		}
		defer txRows.Close()

		for txRows.Next() {
			t, err := ScanTransactionRecord(txRows)
			if err != nil {
				return nil, err
			}
			transactionsByProductCode[t.JanCode] = append(transactionsByProductCode[t.JanCode], t)
		}
	}

	var result []model.StockLedgerYJGroup
	for yjCode, mastersInYjGroup := range mastersByYjCode {
		if len(mastersInYjGroup) == 0 {
			continue
		}

		representativeProductName := mastersInYjGroup[0].ProductName
		for _, master := range mastersInYjGroup {
			isComplete := false
			if txs, ok := transactionsByProductCode[master.ProductCode]; ok {
				for _, t := range txs {
					if t.ProcessFlagMA == "COMPLETE" {
						isComplete = true
						break
					}
				}
			}
			if isComplete {
				representativeProductName = master.ProductName
				break
			}
		}

		yjGroup := model.StockLedgerYJGroup{
			YjCode:      yjCode,
			ProductName: representativeProductName,
			YjUnitName:  units.ResolveName(mastersInYjGroup[0].YjUnitName),
		}

		mastersByPackageKey := make(map[string][]*model.ProductMaster)
		for _, m := range mastersInYjGroup {
			key := fmt.Sprintf("%s|%g|%s", m.PackageForm, m.JanPackInnerQty, m.YjUnitName)
			mastersByPackageKey[key] = append(mastersByPackageKey[key], m)
		}

		var allPackageLedgers []model.StockLedgerPackageGroup
		for key, mastersInPackageGroup := range mastersByPackageKey {
			pkgTxs := []*model.TransactionRecord{}
			for _, m := range mastersInPackageGroup {
				pkgTxs = append(pkgTxs, transactionsByProductCode[m.ProductCode]...)
			}
			sort.Slice(pkgTxs, func(i, j int) bool {
				if pkgTxs[i].TransactionDate != pkgTxs[j].TransactionDate {
					return pkgTxs[i].TransactionDate < pkgTxs[j].TransactionDate
				}
				return pkgTxs[i].ID < pkgTxs[j].ID
			})

			pkg := model.StockLedgerPackageGroup{PackageKey: key}

			inventoryDayTotals := make(map[string]float64)
			hasInventoryInGroup := false
			for _, t := range pkgTxs {
				if t.Flag == 0 {
					inventoryDayTotals[t.TransactionDate] += t.YjQuantity
					hasInventoryInGroup = true
				}
			}

			var netChange, maxUsage float64
			var runningBalance float64
			var transactions []model.LedgerTransaction

			if !hasInventoryInGroup {
				pkg.StartingBalance = "期間棚卸なし"
				pkg.EndingBalance = "期間棚卸なし"
				runningBalance = 0.0
				for _, t := range pkgTxs {
					runningBalance += t.SignedYjQty()
					transactions = append(transactions, model.LedgerTransaction{TransactionRecord: *t, RunningBalance: runningBalance})
				}
			} else {
				runningBalance = 0.0
				var startingBalanceQty float64
				isStartingBalanceSet := false

				for _, t := range pkgTxs {
					if t.Flag == 0 {
						if !isStartingBalanceSet {
							startingBalanceQty = inventoryDayTotals[t.TransactionDate]
							isStartingBalanceSet = true
						}
						break
					}
				}

				for i, t := range pkgTxs {
					_, isInventoryDay := inventoryDayTotals[t.TransactionDate]

					if i > 0 && t.TransactionDate != pkgTxs[i-1].TransactionDate {
						prevDate := pkgTxs[i-1].TransactionDate
						if invTotal, wasInvDay := inventoryDayTotals[prevDate]; wasInvDay {
							runningBalance = invTotal
						}
					}

					if isInventoryDay {
						if t.Flag != 0 {
							tempBalance := runningBalance + t.SignedYjQty()
							transactions = append(transactions, model.LedgerTransaction{TransactionRecord: *t, RunningBalance: tempBalance})
						} else {
							runningBalance = inventoryDayTotals[t.TransactionDate]
							transactions = append(transactions, model.LedgerTransaction{TransactionRecord: *t, RunningBalance: runningBalance})
						}
					} else {
						runningBalance += t.SignedYjQty()
						transactions = append(transactions, model.LedgerTransaction{TransactionRecord: *t, RunningBalance: runningBalance})
					}
				}

				if len(pkgTxs) > 0 {
					lastDate := pkgTxs[len(pkgTxs)-1].TransactionDate
					if invTotal, wasInvDay := inventoryDayTotals[lastDate]; wasInvDay {
						runningBalance = invTotal
						for i := len(transactions) - 1; i >= 0; i-- {
							if transactions[i].TransactionDate == lastDate {
								transactions[i].RunningBalance = runningBalance
							} else {
								break
							}
						}
					}
				}

				if isStartingBalanceSet {
					pkg.StartingBalance = startingBalanceQty
				} else {
					pkg.StartingBalance = "期間棚卸なし"
				}
				pkg.EndingBalance = runningBalance
			}

			for _, t := range pkgTxs {
				netChange += t.SignedYjQty()
				if t.Flag == 3 && t.YjQuantity > maxUsage {
					maxUsage = t.YjQuantity
				}
			}

			pkg.Transactions = transactions
			pkg.NetChange = netChange
			pkg.MaxUsage = maxUsage
			pkg.ReorderPoint = maxUsage * filters.Coefficient

			if endBalanceFloat, ok := pkg.EndingBalance.(float64); ok {
				pkg.IsReorderNeeded = endBalanceFloat < pkg.ReorderPoint && pkg.MaxUsage > 0
			}
			allPackageLedgers = append(allPackageLedgers, pkg)
		}

		if len(allPackageLedgers) > 0 {
			var yjTotalEnding, yjTotalNetChange, yjTotalReorderPoint float64
			var yjTotalStarting interface{}
			isYjReorderNeeded := false
			hasAnyInventory := false

			for _, pkg := range allPackageLedgers {
				if start, ok := pkg.StartingBalance.(float64); ok {
					if !hasAnyInventory {
						yjTotalStarting = float64(0)
						hasAnyInventory = true
					}
					if val, ok := yjTotalStarting.(float64); ok {
						yjTotalStarting = val + start
					}
				}

				if end, ok := pkg.EndingBalance.(float64); ok {
					yjTotalEnding += end
				}
				yjTotalNetChange += pkg.NetChange
				yjTotalReorderPoint += pkg.ReorderPoint
				if pkg.IsReorderNeeded {
					isYjReorderNeeded = true
				}
			}

			if !hasAnyInventory {
				yjGroup.StartingBalance = "期間棚卸なし"
				yjGroup.EndingBalance = "期間棚卸なし"
			} else {
				yjGroup.StartingBalance = yjTotalStarting
				yjGroup.EndingBalance = yjTotalEnding
			}

			yjGroup.NetChange = yjTotalNetChange
			yjGroup.TotalReorderPoint = yjTotalReorderPoint
			yjGroup.IsReorderNeeded = isYjReorderNeeded
			yjGroup.PackageLedgers = allPackageLedgers
			result = append(result, yjGroup)
		}
	}

	// ▼▼▼ [修正点] 診断用ログを削除し、最終的なソートロジックを確定 ▼▼▼
	sort.Slice(result, func(i, j int) bool {
		// 【修正点】キーに日本語の文字を追加し、両方に対応させる
		prio := map[string]int{
			"1": 1, "内": 1,
			"2": 2, "外": 2,
			"3": 3, "歯": 3,
			"4": 4, "注": 4,
			"5": 5, "機": 5, // 「機」という文字にも対応
			"6": 6, "他": 6, // 「他」という文字にも対応
		}

		masterI := mastersByYjCode[result[i].YjCode][0]
		masterJ := mastersByYjCode[result[j].YjCode][0]

		prioI, okI := prio[strings.TrimSpace(masterI.UsageClassification)]
		if !okI {
			prioI = 6 // その他のデフォルト優先順位
		}

		prioJ, okJ := prio[strings.TrimSpace(masterJ.UsageClassification)]
		if !okJ {
			prioJ = 6 // その他のデフォルト優先順位
		}

		if prioI != prioJ {
			return prioI < prioJ
		}
		return masterI.KanaName < masterJ.KanaName
	})
	// ▲▲▲ 修正ここまで ▲▲▲

	return result, nil
}


----- C:\Dev\WASABI\db\clients.go -----
package db

import (
	"database/sql"
	"fmt"
	"wasabi/model" // <-- IMPORT ADDED
)

// CreateClientInTx creates a new client record within a transaction.
func CreateClientInTx(tx *sql.Tx, code, name string) error {
	const q = `INSERT INTO client_master (client_code, client_name) VALUES (?, ?)`
	_, err := tx.Exec(q, code, name)
	if err != nil {
		return fmt.Errorf("CreateClientInTx failed: %w", err)
	}
	return nil
}

// CheckClientExistsByName checks if a client with the given name already exists.
func CheckClientExistsByName(tx *sql.Tx, name string) (bool, error) {
	var exists int
	const q = `SELECT 1 FROM client_master WHERE client_name = ? LIMIT 1`
	err := tx.QueryRow(q, name).Scan(&exists)
	if err != nil {
		if err == sql.ErrNoRows {
			return false, nil // Does not exist
		}
		return false, fmt.Errorf("CheckClientExistsByName failed: %w", err) // Other error
	}
	return true, nil // Exists
}

// GetAllClients retrieves all clients from the client_master table.
func GetAllClients(conn *sql.DB) ([]model.Client, error) {
	rows, err := conn.Query("SELECT client_code, client_name FROM client_master ORDER BY client_code")
	if err != nil {
		return nil, fmt.Errorf("failed to get all clients: %w", err)
	}
	defer rows.Close()

	var clients []model.Client
	for rows.Next() {
		var c model.Client
		if err := rows.Scan(&c.Code, &c.Name); err != nil {
			return nil, err
		}
		clients = append(clients, c)
	}
	return clients, nil
}


----- C:\Dev\WASABI\db\deadstock.go -----
// C:\Dev\WASABI\db\deadstock.go

package db

import (
	"database/sql"
	"fmt"
	"sort"
	"strings"
	"time"
	"wasabi/model"
)

func GetDeadStockList(tx *sql.Tx, filters model.DeadStockFilters) ([]model.DeadStockGroup, error) {
	rows, err := tx.Query(`SELECT ` + TransactionColumns + ` FROM transaction_records ORDER BY transaction_date, id`)
	if err != nil {
		return nil, fmt.Errorf("failed to get all transactions: %w", err)
	}
	defer rows.Close()

	txsByProductCode := make(map[string][]*model.TransactionRecord)
	masters := make(map[string]*model.ProductMaster)
	for rows.Next() {
		r, err := ScanTransactionRecord(rows)
		if err != nil {
			return nil, err
		}
		txsByProductCode[r.JanCode] = append(txsByProductCode[r.JanCode], r)
		if _, ok := masters[r.JanCode]; !ok {
			masters[r.JanCode] = r.ToProductMaster()
		}
	}

	groups := make(map[string][]*model.ProductMaster)
	for _, m := range masters {
		if m.YjCode != "" {
			groups[m.YjCode] = append(groups[m.YjCode], m)
		}
	}

	deadStockMajorGroups := make(map[string]bool)
	for yjCode, masterList := range groups {
		packagesByMinorGroupKey := make(map[string][]*model.ProductMaster)
		for _, m := range masterList {
			key := fmt.Sprintf("%s|%g|%s", m.PackageForm, m.JanPackInnerQty, m.YjUnitName)
			packagesByMinorGroupKey[key] = append(packagesByMinorGroupKey[key], m)
		}

		isDeadStockCandidate := false
		for _, mastersInMinorGroup := range packagesByMinorGroupKey {
			var maxUsage float64
			for _, master := range mastersInMinorGroup {
				for _, t := range txsByProductCode[master.ProductCode] {
					if t.Flag == 3 && t.TransactionDate >= filters.StartDate && t.TransactionDate <= filters.EndDate {
						if t.YjQuantity > maxUsage {
							maxUsage = t.YjQuantity
						}
					}
				}
			}

			if maxUsage*filters.Coefficient == 0 {
				isDeadStockCandidate = true
				break
			}
		}

		if isDeadStockCandidate {
			deadStockMajorGroups[yjCode] = true
		}
	}

	var result []model.DeadStockGroup
	for yjCode, masterList := range groups {
		if !deadStockMajorGroups[yjCode] {
			continue
		}
		if len(masterList) == 0 {
			continue
		}

		dsg := model.DeadStockGroup{
			YjCode:      yjCode,
			ProductName: masterList[0].ProductName,
		}

		packagesByMinorGroupKey := make(map[string][]*model.ProductMaster)
		for _, m := range masterList {
			key := fmt.Sprintf("%s|%g|%s", m.PackageForm, m.JanPackInnerQty, m.YjUnitName)
			packagesByMinorGroupKey[key] = append(packagesByMinorGroupKey[key], m)
		}

		var totalStock float64
		var finalPackages []model.DeadStockPackage

		for _, mastersInMinorGroup := range packagesByMinorGroupKey {
			if len(mastersInMinorGroup) == 0 {
				continue
			}

			var aggregatedStock float64
			var aggregatedSavedRecords []model.DeadStockRecord

			for _, master := range mastersInMinorGroup {
				stock, _ := calculateCurrentStock(txsByProductCode[master.ProductCode])
				aggregatedStock += stock

				savedRecords, err := getSavedDeadStock(tx, master.ProductCode)
				if err != nil {
					return nil, err
				}
				aggregatedSavedRecords = append(aggregatedSavedRecords, savedRecords...)
			}

			repMaster := mastersInMinorGroup[0]
			finalPackages = append(finalPackages, model.DeadStockPackage{
				ProductMaster: *repMaster,
				CurrentStock:  aggregatedStock,
				SavedRecords:  aggregatedSavedRecords,
			})
			totalStock += aggregatedStock
		}

		dsg.TotalStock = totalStock
		dsg.Packages = finalPackages

		if filters.ExcludeZeroStock && dsg.TotalStock <= 0 {
			continue
		}

		if len(dsg.Packages) > 0 {
			result = append(result, dsg)
		}
	}

	// ▼▼▼ [修正点] 診断用ログを削除し、最終的なソートロジックを確定 ▼▼▼
	sort.Slice(result, func(i, j int) bool {
		prio := map[string]int{
			"1": 1, "内": 1,
			"2": 2, "外": 2,
			"3": 3, "歯": 3,
			"4": 4, "注": 4,
			"5": 5, "機": 5, // 「機」という文字にも対応
			"6": 6, "他": 6, // 「他」という文字にも対応
		}

		if len(result[i].Packages) == 0 || len(result[j].Packages) == 0 {
			return false
		}
		masterI := result[i].Packages[0].ProductMaster
		masterJ := result[j].Packages[0].ProductMaster

		prioI, okI := prio[strings.TrimSpace(masterI.UsageClassification)]
		if !okI {
			prioI = 6
		}

		prioJ, okJ := prio[strings.TrimSpace(masterJ.UsageClassification)]
		if !okJ { // ← この部分を `!okJ` に正しく修正します
			prioJ = 6
		}

		if prioI != prioJ {
			return prioI < prioJ
		}
		return masterI.KanaName < masterJ.KanaName
	})
	// ▲▲▲ 修正ここまで ▲▲▲

	return result, nil
}

// (calculateCurrentStock, getSavedDeadStock, UpsertDeadStockRecordsInTx functions are unchanged)
func calculateCurrentStock(txs []*model.TransactionRecord) (float64, error) {
	inventoryDayTotals := make(map[string]float64)
	hasInventory := false
	for _, t := range txs {
		if t.Flag == 0 {
			inventoryDayTotals[t.TransactionDate] += t.YjQuantity
			hasInventory = true
		}
	}
	var runningBalance float64
	if !hasInventory {
		for _, t := range txs {
			runningBalance += t.SignedYjQty()
		}
	} else {
		for i, t := range txs {
			if i > 0 && t.TransactionDate != txs[i-1].TransactionDate {
				prevDate := txs[i-1].TransactionDate
				if invTotal, wasInvDay := inventoryDayTotals[prevDate]; wasInvDay {
					runningBalance = invTotal
				}
			}
			if invTotal, isInvDay := inventoryDayTotals[t.TransactionDate]; isInvDay {
				if t.Flag == 0 {
					runningBalance = invTotal
				}
			} else {
				runningBalance += t.SignedYjQty()
			}
		}
		if len(txs) > 0 {
			lastDate := txs[len(txs)-1].TransactionDate
			if invTotal, wasInvDay := inventoryDayTotals[lastDate]; wasInvDay {
				runningBalance = invTotal
			}
		}
	}
	return runningBalance, nil
}
func getSavedDeadStock(tx *sql.Tx, productCode string) ([]model.DeadStockRecord, error) {
	const q = `SELECT id, stock_quantity_jan, expiry_date, lot_number FROM dead_stock_list WHERE product_code = ? ORDER BY id`
	rows, err := tx.Query(q, productCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var records []model.DeadStockRecord
	for rows.Next() {
		var r model.DeadStockRecord
		if err := rows.Scan(&r.ID, &r.StockQuantityJan, &r.ExpiryDate, &r.LotNumber); err != nil {
			return nil, err
		}
		records = append(records, r)
	}
	return records, nil
}
func UpsertDeadStockRecordsInTx(tx *sql.Tx, records []model.DeadStockRecord) error {
	productCodes := make(map[string]struct{})
	for _, r := range records {
		productCodes[r.ProductCode] = struct{}{}
	}

	if len(productCodes) > 0 {
		var args []interface{}
		var placeholders []string
		for pc := range productCodes {
			args = append(args, pc)
			placeholders = append(placeholders, "?")
		}
		deleteQuery := `DELETE FROM dead_stock_list WHERE product_code IN (` + strings.Join(placeholders, ",") + `)`
		if _, err := tx.Exec(deleteQuery, args...); err != nil {
			return fmt.Errorf("failed to delete old dead stock records: %w", err)
		}
	}

	const q = `INSERT INTO dead_stock_list (
		product_code, yj_code, package_form, jan_pack_inner_qty, yj_unit_name,
		stock_quantity_jan, expiry_date, lot_number, created_at
	) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`

	stmt, err := tx.Prepare(q)
	if err != nil {
		return fmt.Errorf("failed to prepare dead_stock_list statement: %w", err)
	}
	defer stmt.Close()

	for _, r := range records {
		if r.StockQuantityJan <= 0 && r.ExpiryDate == "" && r.LotNumber == "" {
			continue
		}
		_, err := stmt.Exec(
			r.ProductCode, r.YjCode, r.PackageForm, r.JanPackInnerQty, r.YjUnitName,
			r.StockQuantityJan, r.ExpiryDate, r.LotNumber, time.Now().Format("2006-01-02 15:04:05"),
		)
		if err != nil {
			return fmt.Errorf("failed to insert into dead_stock_list: %w", err)
		}
	}
	return nil
}


----- C:\Dev\WASABI\db\handlers.go -----
package db

import (
	"database/sql"
	"encoding/json"
	"net/http"
)

// GetAllClientsHandler は /api/clients のリクエストを処理します。
func GetAllClientsHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		clients, err := GetAllClients(conn)
		if err != nil {
			http.Error(w, "Failed to get clients", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(clients)
	}
}

// SearchJcshmsByNameHandler は /api/products/search のリクエストを処理します。
func SearchJcshmsByNameHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		query := r.URL.Query().Get("q")
		if len(query) < 2 {
			http.Error(w, "Query must be at least 2 characters", http.StatusBadRequest)
			return
		}
		results, err := SearchJcshmsByName(conn, query)
		if err != nil {
			http.Error(w, "Failed to search products", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(results)
	}
}


----- C:\Dev\WASABI\db\jcshms.go -----
// C:\Dev\WASABI\db\jcshms.go

package db

import (
	"database/sql"
	"fmt"
	"strconv"
	"strings"
	"wasabi/model"
)

// ▼▼▼ [修正点] 引数を conn *sql.DB から tx *sql.Tx に変更 ▼▼▼
// GetJcshmsByCodesMap gets JCSHMS/JANCODE master info for multiple JAN codes.
func GetJcshmsByCodesMap(tx *sql.Tx, jans []string) (map[string]*model.JCShms, error) {
	if len(jans) == 0 {
		return make(map[string]*model.JCShms), nil
	}

	results := make(map[string]*model.JCShms)
	args := make([]interface{}, len(jans))
	for i, jan := range jans {
		args[i] = jan
		// Initialize the map entry to avoid nil pointer issues later
		results[jan] = &model.JCShms{}
	}

	inClause := `(?` + strings.Repeat(",?", len(jans)-1) + `)`

	// Query jcshms table
	q1 := `SELECT JC000, JC009, JC013, JC018, JC022, JC030, JC037, JC039, JC044, JC050,
	              JC061, JC062, JC063, JC064, JC065, JC066
	       FROM jcshms WHERE JC000 IN ` + inClause
	rows1, err := tx.Query(q1, args...) // conn.Query から tx.Query に変更
	if err != nil {
		return nil, fmt.Errorf("jcshms bulk search failed: %w", err)
	}
	defer rows1.Close()

	for rows1.Next() {
		var jan string
		var jcshmsPart model.JCShms
		var jc050 sql.NullString

		if err := rows1.Scan(&jan, &jcshmsPart.JC009, &jcshmsPart.JC013, &jcshmsPart.JC018, &jcshmsPart.JC022, &jcshmsPart.JC030,
			&jcshmsPart.JC037, &jcshmsPart.JC039, &jcshmsPart.JC044, &jc050,
			&jcshmsPart.JC061, &jcshmsPart.JC062, &jcshmsPart.JC063, &jcshmsPart.JC064, &jcshmsPart.JC065, &jcshmsPart.JC066,
		); err != nil {
			return nil, err
		}

		res := results[jan]
		res.JC009, res.JC013, res.JC018, res.JC022 = jcshmsPart.JC009, jcshmsPart.JC013, jcshmsPart.JC018, jcshmsPart.JC022
		res.JC030, res.JC037, res.JC039 = jcshmsPart.JC030, jcshmsPart.JC037, jcshmsPart.JC039
		res.JC044 = jcshmsPart.JC044
		res.JC061, res.JC062, res.JC063, res.JC064, res.JC065, res.JC066 = jcshmsPart.JC061, jcshmsPart.JC062, jcshmsPart.JC063, jcshmsPart.JC064, jcshmsPart.JC065, jcshmsPart.JC066

		val, err := strconv.ParseFloat(jc050.String, 64)
		if err != nil {
			res.JC050 = 0
		} else {
			res.JC050 = val
		}
	}

	// Query jancode table
	q2 := `SELECT JA001, JA006, JA007, JA008 FROM jancode WHERE JA001 IN ` + inClause
	rows2, err := tx.Query(q2, args...) // conn.Query から tx.Query に変更
	if err != nil {
		return nil, fmt.Errorf("jancode bulk search failed: %w", err)
	}
	defer rows2.Close()

	for rows2.Next() {
		var jan string
		var jaPart struct {
			JA006 sql.NullFloat64
			JA007 sql.NullString
			JA008 sql.NullFloat64
		}
		if err := rows2.Scan(&jan, &jaPart.JA006, &jaPart.JA007, &jaPart.JA008); err != nil {
			return nil, err
		}
		results[jan].JA006 = jaPart.JA006
		results[jan].JA007 = jaPart.JA007
		results[jan].JA008 = jaPart.JA008
	}

	return results, nil
}

// ▲▲▲ 修正ここまで ▲▲▲


----- C:\Dev\WASABI\db\product_master.go -----
// C:\Dev\WASABI\db\product_master.go

package db

import (
	"database/sql"
	"fmt"
	"strings"
	"wasabi/model"
	"wasabi/units"
)

// selectColumns is a reusable string for selecting all columns from the product_master table.
const selectColumns = `
	product_code, yj_code, product_name, origin, kana_name, maker_name,
	usage_classification, package_form, package_spec, yj_unit_name, yj_pack_unit_qty,
	flag_poison, flag_deleterious, flag_narcotic, flag_psychotropic,
	flag_stimulant, flag_stimulant_raw, jan_pack_inner_qty, jan_unit_code,
	jan_pack_unit_qty, nhi_price, purchase_price, supplier_wholesale
`

// scanProductMaster maps a database row to a ProductMaster struct.
func scanProductMaster(row interface{ Scan(...interface{}) error }) (*model.ProductMaster, error) {
	var m model.ProductMaster
	err := row.Scan(
		&m.ProductCode, &m.YjCode, &m.ProductName, &m.Origin, &m.KanaName, &m.MakerName,
		&m.UsageClassification, &m.PackageForm, &m.PackageSpec, &m.YjUnitName, &m.YjPackUnitQty,
		&m.FlagPoison, &m.FlagDeleterious, &m.FlagNarcotic, &m.FlagPsychotropic,
		&m.FlagStimulant, &m.FlagStimulantRaw, &m.JanPackInnerQty, &m.JanUnitCode,
		&m.JanPackUnitQty, &m.NhiPrice, &m.PurchasePrice, &m.SupplierWholesale,
	)
	if err != nil {
		return nil, err
	}
	return &m, nil
}

// CreateProductMasterInTx creates a new product master within a transaction.
func CreateProductMasterInTx(tx *sql.Tx, rec model.ProductMasterInput) error {
	const q = `INSERT INTO product_master (
		product_code, yj_code, product_name, origin, kana_name, maker_name,
		usage_classification, package_form, package_spec, yj_unit_name, yj_pack_unit_qty,
		flag_poison, flag_deleterious, flag_narcotic, flag_psychotropic,
		flag_stimulant, flag_stimulant_raw, jan_pack_inner_qty, jan_unit_code,
		jan_pack_unit_qty, nhi_price, purchase_price, supplier_wholesale
	) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`

	_, err := tx.Exec(q,
		rec.ProductCode, rec.YjCode, rec.ProductName, rec.Origin, rec.KanaName, rec.MakerName,
		rec.UsageClassification, rec.PackageForm, rec.PackageSpec, rec.YjUnitName, rec.YjPackUnitQty,
		rec.FlagPoison, rec.FlagDeleterious, rec.FlagNarcotic, rec.FlagPsychotropic,
		rec.FlagStimulant, rec.FlagStimulantRaw, rec.JanPackInnerQty, rec.JanUnitCode,
		rec.JanPackUnitQty, rec.NhiPrice, rec.PurchasePrice, rec.SupplierWholesale,
	)
	if err != nil {
		return fmt.Errorf("CreateProductMasterInTx failed: %w", err)
	}
	return nil
}

// UpsertProductMasterInTx updates a product master or inserts it if it doesn't exist.
func UpsertProductMasterInTx(tx *sql.Tx, rec model.ProductMasterInput) error {
	const q = `INSERT INTO product_master (
		product_code, yj_code, product_name, origin, kana_name, maker_name,
		usage_classification, package_form, package_spec, yj_unit_name, yj_pack_unit_qty,
		flag_poison, flag_deleterious, flag_narcotic, flag_psychotropic,
		flag_stimulant, flag_stimulant_raw, jan_pack_inner_qty, jan_unit_code,
		jan_pack_unit_qty, nhi_price, purchase_price, supplier_wholesale
	) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
	ON CONFLICT(product_code) DO UPDATE SET
		yj_code=excluded.yj_code, product_name=excluded.product_name, origin=excluded.origin, 
		kana_name=excluded.kana_name, maker_name=excluded.maker_name, 
		usage_classification=excluded.usage_classification, package_form=excluded.package_form, 
		package_spec=excluded.package_spec, yj_unit_name=excluded.yj_unit_name, 
		yj_pack_unit_qty=excluded.yj_pack_unit_qty, flag_poison=excluded.flag_poison, 
		flag_deleterious=excluded.flag_deleterious, flag_narcotic=excluded.flag_narcotic, 
		flag_psychotropic=excluded.flag_psychotropic, flag_stimulant=excluded.flag_stimulant, 
		flag_stimulant_raw=excluded.flag_stimulant_raw, jan_pack_inner_qty=excluded.jan_pack_inner_qty, 
		jan_unit_code=excluded.jan_unit_code, jan_pack_unit_qty=excluded.jan_pack_unit_qty, 
		nhi_price=excluded.nhi_price, purchase_price=excluded.purchase_price, 
		supplier_wholesale=excluded.supplier_wholesale`

	_, err := tx.Exec(q,
		rec.ProductCode, rec.YjCode, rec.ProductName, rec.Origin, rec.KanaName, rec.MakerName,
		rec.UsageClassification, rec.PackageForm, rec.PackageSpec, rec.YjUnitName, rec.YjPackUnitQty,
		rec.FlagPoison, rec.FlagDeleterious, rec.FlagNarcotic, rec.FlagPsychotropic,
		rec.FlagStimulant, rec.FlagStimulantRaw, rec.JanPackInnerQty, rec.JanUnitCode,
		rec.JanPackUnitQty, rec.NhiPrice, rec.PurchasePrice, rec.SupplierWholesale,
	)
	if err != nil {
		return fmt.Errorf("UpsertProductMasterInTx failed: %w", err)
	}
	return nil
}

// GetProductMasterByCode は製品コードをキーに単一の製品マスターを取得します。
func GetProductMasterByCode(conn *sql.DB, code string) (*model.ProductMaster, error) {
	q := `SELECT ` + selectColumns + ` FROM product_master WHERE product_code = ? LIMIT 1`
	m, err := scanProductMaster(conn.QueryRow(q, code))
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, fmt.Errorf("GetProductMasterByCode failed: %w", err)
	}
	return m, nil
}

// ▼▼▼ [修正点] 引数を conn *sql.DB から tx *sql.Tx に変更 ▼▼▼
// GetProductMastersByCodesMap は複数の製品コードをキーに製品マスターをマップで取得します。
func GetProductMastersByCodesMap(tx *sql.Tx, codes []string) (map[string]*model.ProductMaster, error) {
	if len(codes) == 0 {
		return make(map[string]*model.ProductMaster), nil
	}
	q := `SELECT ` + selectColumns + ` FROM product_master WHERE product_code IN (?` + strings.Repeat(",?", len(codes)-1) + `)`

	args := make([]interface{}, len(codes))
	for i, code := range codes {
		args[i] = code
	}

	rows, err := tx.Query(q, args...) // conn.Query から tx.Query に変更
	if err != nil {
		return nil, fmt.Errorf("query for masters by codes failed: %w", err)
	}
	defer rows.Close()

	mastersMap := make(map[string]*model.ProductMaster)
	for rows.Next() {
		m, err := scanProductMaster(rows)
		if err != nil {
			return nil, err
		}
		mastersMap[m.ProductCode] = m
	}
	return mastersMap, nil
}

// ▲▲▲ 修正ここまで ▲▲▲

// GetEditableProductMasters fetches all non-JCSHMS product masters for the edit screen.
func GetEditableProductMasters(conn *sql.DB) ([]model.ProductMasterView, error) {
	q := `SELECT ` + selectColumns + ` FROM product_master WHERE origin != 'JCSHMS' ORDER BY kana_name`

	rows, err := conn.Query(q)
	if err != nil {
		return nil, fmt.Errorf("GetEditableProductMasters failed: %w", err)
	}
	defer rows.Close()

	var mastersView []model.ProductMasterView
	for rows.Next() {
		m, err := scanProductMaster(rows)
		if err != nil {
			return nil, err
		}

		tempJcshms := model.JCShms{
			JC037: m.PackageSpec,
			JC039: m.YjUnitName,
			JC044: m.YjPackUnitQty,
			JA006: sql.NullFloat64{Float64: m.JanPackInnerQty, Valid: true},
			JA008: sql.NullFloat64{Float64: m.JanPackUnitQty, Valid: true},
			JA007: sql.NullString{String: fmt.Sprintf("%d", m.JanUnitCode), Valid: true},
		}
		formattedSpec := units.FormatPackageSpec(&tempJcshms)

		mastersView = append(mastersView, model.ProductMasterView{
			ProductMaster:        *m,
			FormattedPackageSpec: formattedSpec,
		})
	}
	return mastersView, nil
}

// GetAllProductMasters retrieves all product master records.
func GetAllProductMasters(conn *sql.DB) ([]*model.ProductMaster, error) {
	// 【修正点】ORDER BY句にCASE文を追加して優先順位ソートを実装
	q := `SELECT ` + selectColumns + ` FROM product_master 
		ORDER BY
			CASE
				WHEN usage_classification = '1' OR usage_classification = '内' THEN 1
				WHEN usage_classification = '2' OR usage_classification = '外' THEN 2
				WHEN usage_classification = '3' OR usage_classification = '歯' THEN 3
				WHEN usage_classification = '4' OR usage_classification = '注' THEN 4
				WHEN usage_classification = '5' OR usage_classification = '機' THEN 5
				WHEN usage_classification = '6' OR usage_classification = '他' THEN 6
				ELSE 7
			END,
			kana_name`

	rows, err := conn.Query(q)
	if err != nil {
		return nil, fmt.Errorf("GetAllProductMasters failed: %w", err)
	}
	defer rows.Close()

	var masters []*model.ProductMaster
	for rows.Next() {
		m, err := scanProductMaster(rows)
		if err != nil {
			return nil, err
		}
		masters = append(masters, m)
	}
	return masters, nil
}


----- C:\Dev\WASABI\db\search.go -----
package db

import (
	"database/sql"
	"fmt"
	"log"
	"strconv"
	"wasabi/model"
	"wasabi/units"
)

// SearchJcshmsByName は製品名またはカナ名（部分一致）でJCSHMSマスタを検索し、表示用のモデルを返します。
func SearchJcshmsByName(conn *sql.DB, nameQuery string) ([]model.ProductMasterView, error) {
	const q = `
		SELECT
			j.JC000, j.JC009, j.JC018, j.JC022, j.JC030, j.JC013, j.JC037, j.JC039,
			j.JC044, j.JC050,
			ja.JA006, ja.JA008, ja.JA007
		FROM jcshms AS j
		LEFT JOIN jancode AS ja ON j.JC000 = ja.JA001
		WHERE j.JC018 LIKE ? OR j.JC022 LIKE ?
		ORDER BY j.JC022
		LIMIT 500`

	rows, err := conn.Query(q, "%"+nameQuery+"%", "%"+nameQuery+"%")
	if err != nil {
		return nil, fmt.Errorf("SearchJcshmsByName failed: %w", err)
	}
	defer rows.Close()

	var results []model.ProductMasterView
	for rows.Next() {
		var tempJcshms model.JCShms
		var jc000, jc009, jc018, jc022, jc030, jc013, jc037, jc039, jc050 sql.NullString
		var jc044 sql.NullFloat64

		if err := rows.Scan(
			&jc000, &jc009, &jc018, &jc022, &jc030, &jc013, &jc037, &jc039,
			&jc044, &jc050,
			&tempJcshms.JA006, &tempJcshms.JA008, &tempJcshms.JA007,
		); err != nil {
			return nil, err
		}

		tempJcshms.JC013 = jc013.String
		tempJcshms.JC037 = jc037.String
		tempJcshms.JC039 = jc039.String
		tempJcshms.JC044 = jc044.Float64

		nhiPriceVal, err := strconv.ParseFloat(jc050.String, 64)
		if err != nil {
			nhiPriceVal = 0
			if jc050.String != "" {
				log.Printf("[WARN] Invalid JC050 data during search: '%s'", jc050.String)
			}
		}
		tempJcshms.JC050 = nhiPriceVal

		var unitNhiPrice float64
		if tempJcshms.JC044 > 0 {
			unitNhiPrice = tempJcshms.JC050 / tempJcshms.JC044
		}

		janUnitCodeInt, _ := strconv.Atoi(tempJcshms.JA007.String)

		view := model.ProductMasterView{
			ProductMaster: model.ProductMaster{
				ProductCode:         jc000.String,
				YjCode:              jc009.String,
				ProductName:         jc018.String,
				KanaName:            jc022.String,
				MakerName:           jc030.String,
				UsageClassification: jc013.String,
				PackageForm:         jc037.String,
				PackageSpec:         jc037.String,
				YjUnitName:          units.ResolveName(jc039.String),
				YjPackUnitQty:       jc044.Float64,
				JanPackInnerQty:     tempJcshms.JA006.Float64,
				JanPackUnitQty:      tempJcshms.JA008.Float64,
				JanUnitCode:         janUnitCodeInt,
				NhiPrice:            unitNhiPrice,
			},
			FormattedPackageSpec: units.FormatPackageSpec(&tempJcshms),
		}
		results = append(results, view)
	}
	return results, nil
}


----- C:\Dev\WASABI\db\sequence.go -----
package db

import (
	"database/sql"
	"fmt"
	"log"
	"strconv"
	"strings"
)

func NextSequenceInTx(tx *sql.Tx, name, prefix string, padding int) (string, error) {
	var lastNo int
	err := tx.QueryRow("SELECT last_no FROM code_sequences WHERE name = ?", name).Scan(&lastNo)
	if err != nil {
		if err == sql.ErrNoRows {
			return "", fmt.Errorf("sequence '%s' not found", name)
		}
		return "", fmt.Errorf("failed to get sequence '%s': %w", name, err)
	}

	newNo := lastNo + 1
	_, err = tx.Exec("UPDATE code_sequences SET last_no = ? WHERE name = ?", newNo, name)
	if err != nil {
		return "", fmt.Errorf("failed to update sequence '%s': %w", name, err)
	}

	format := fmt.Sprintf("%s%%0%dd", prefix, padding)
	return fmt.Sprintf(format, newNo), nil
}

// InitializeSequenceFromMaxYjCode resets the MA2Y sequence based on the max yj_code in product_master.
func InitializeSequenceFromMaxYjCode(conn *sql.DB) error {
	var maxNo int64 = 0
	prefix := "MA2Y"
	rows, err := conn.Query("SELECT yj_code FROM product_master WHERE yj_code LIKE ?", prefix+"%")
	if err != nil {
		return fmt.Errorf("failed to query existing yj_codes: %w", err)
	}
	defer rows.Close()

	for rows.Next() {
		var yjCode string
		if err := rows.Scan(&yjCode); err != nil {
			log.Printf("Warn: could not scan yj_code: %v", err)
			continue
		}
		numPart := strings.TrimPrefix(yjCode, prefix)
		if num, err := strconv.ParseInt(numPart, 10, 64); err == nil {
			if num > maxNo {
				maxNo = num
			}
		}
	}

	if maxNo > 0 {
		_, err = conn.Exec("UPDATE code_sequences SET last_no = ? WHERE name = ?", maxNo, "MA2Y")
		if err != nil {
			return fmt.Errorf("failed to update MA2Y sequence with max value %d: %w", maxNo, err)
		}
		log.Printf("MA2Y sequence initialized to %d.", maxNo)
	}
	return nil
}

// InitializeSequenceFromMaxClientCode resets the CL sequence based on the max client_code in client_master.
func InitializeSequenceFromMaxClientCode(conn *sql.DB) error {
	var maxNo int64 = 0
	prefix := "CL"
	rows, err := conn.Query("SELECT client_code FROM client_master WHERE client_code LIKE ?", prefix+"%")
	if err != nil {
		return fmt.Errorf("failed to query existing client_codes: %w", err)
	}
	defer rows.Close()

	for rows.Next() {
		var clientCode string
		if err := rows.Scan(&clientCode); err != nil {
			log.Printf("Warn: could not scan client_code: %v", err)
			continue
		}
		numPart := strings.TrimPrefix(clientCode, prefix)
		if num, err := strconv.ParseInt(numPart, 10, 64); err == nil {
			if num > maxNo {
				maxNo = num
			}
		}
	}

	if maxNo > 0 {
		_, err = conn.Exec("UPDATE code_sequences SET last_no = ? WHERE name = ?", maxNo, "CL")
		if err != nil {
			return fmt.Errorf("failed to update CL sequence with max value %d: %w", maxNo, err)
		}
		log.Printf("CL sequence initialized to %d.", maxNo)
	}
	return nil
}


----- C:\Dev\WASABI\db\transaction_records.go -----
// C:\Dev\WASABI\db\transaction_records.go

package db

import (
	"database/sql"
	"fmt"
	"log"
	"wasabi/model"
)

// TransactionColumns is a reusable list of all columns in the transaction_records table.
const TransactionColumns = `
    id, transaction_date, client_code, receipt_number, line_number, flag,
    jan_code, yj_code, product_name, kana_name, usage_classification, package_form, package_spec, maker_name,
    dat_quantity, jan_pack_inner_qty, jan_quantity, jan_pack_unit_qty, jan_unit_name, jan_unit_code,
    yj_quantity, yj_pack_unit_qty, yj_unit_name, unit_price, purchase_price, supplier_wholesale,
	subtotal, tax_amount, tax_rate, expiry_date, lot_number, flag_poison,
    flag_deleterious, flag_narcotic, flag_psychotropic, flag_stimulant,
    flag_stimulant_raw, process_flag_ma, processing_status`

// ScanTransactionRecord maps a database row to a TransactionRecord struct.
func ScanTransactionRecord(row interface{ Scan(...interface{}) error }) (*model.TransactionRecord, error) {
	var r model.TransactionRecord
	err := row.Scan(
		&r.ID, &r.TransactionDate, &r.ClientCode, &r.ReceiptNumber, &r.LineNumber, &r.Flag,
		&r.JanCode, &r.YjCode, &r.ProductName, &r.KanaName, &r.UsageClassification, &r.PackageForm, &r.PackageSpec, &r.MakerName,
		&r.DatQuantity, &r.JanPackInnerQty, &r.JanQuantity, &r.JanPackUnitQty, &r.JanUnitName, &r.JanUnitCode,
		&r.YjQuantity, &r.YjPackUnitQty, &r.YjUnitName, &r.UnitPrice, &r.PurchasePrice, &r.SupplierWholesale,
		&r.Subtotal, &r.TaxAmount, &r.TaxRate, &r.ExpiryDate, &r.LotNumber, &r.FlagPoison,
		&r.FlagDeleterious, &r.FlagNarcotic, &r.FlagPsychotropic, &r.FlagStimulant,
		&r.FlagStimulantRaw, &r.ProcessFlagMA, &r.ProcessingStatus,
	)
	if err != nil {
		return nil, err
	}
	return &r, nil
}

// PersistTransactionRecordsInTx inserts or replaces a slice of transaction records within a transaction.
func PersistTransactionRecordsInTx(tx *sql.Tx, records []model.TransactionRecord) error {
	const q = `
INSERT OR REPLACE INTO transaction_records (
    transaction_date, client_code, receipt_number, line_number, flag,
    jan_code, yj_code, product_name, kana_name, usage_classification, package_form, package_spec, maker_name,
    dat_quantity, jan_pack_inner_qty, jan_quantity, jan_pack_unit_qty, jan_unit_name, jan_unit_code,
    yj_quantity, yj_pack_unit_qty, yj_unit_name, unit_price, purchase_price, supplier_wholesale,
	subtotal, tax_amount, tax_rate, expiry_date, lot_number, flag_poison,
    flag_deleterious, flag_narcotic, flag_psychotropic, flag_stimulant,
    flag_stimulant_raw, process_flag_ma, processing_status
) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)`

	stmt, err := tx.Prepare(q)
	if err != nil {
		return fmt.Errorf("failed to prepare statement for transaction_records: %w", err)
	}
	defer stmt.Close()

	for _, rec := range records {
		_, err = stmt.Exec( // ここは再宣言ではないので = を使用
			rec.TransactionDate, rec.ClientCode, rec.ReceiptNumber, rec.LineNumber, rec.Flag,
			rec.JanCode, rec.YjCode, rec.ProductName, rec.KanaName, rec.UsageClassification, rec.PackageForm, rec.PackageSpec, rec.MakerName,
			rec.DatQuantity, rec.JanPackInnerQty, rec.JanQuantity,
			rec.JanPackUnitQty,
			rec.JanUnitName, rec.JanUnitCode,
			rec.YjQuantity, rec.YjPackUnitQty, rec.YjUnitName, rec.UnitPrice, rec.PurchasePrice, rec.SupplierWholesale,
			rec.Subtotal, rec.TaxAmount, rec.TaxRate, rec.ExpiryDate, rec.LotNumber, rec.FlagPoison,
			rec.FlagDeleterious, rec.FlagNarcotic, rec.FlagPsychotropic, rec.FlagStimulant,
			rec.FlagStimulantRaw, rec.ProcessFlagMA, rec.ProcessingStatus,
		)
		if err != nil {
			log.Printf("FAILED to insert into transaction_records: JAN=%s, Error: %v", rec.JanCode, err)
			return fmt.Errorf("failed to exec statement for transaction_records (JAN: %s): %w", rec.JanCode, err)
		}
	}
	return nil
}

// GetReceiptNumbersByDate returns a list of unique receipt numbers for a given date.
func GetReceiptNumbersByDate(conn *sql.DB, date string) ([]string, error) {
	const q = `SELECT DISTINCT receipt_number FROM transaction_records WHERE transaction_date = ? ORDER BY receipt_number`
	rows, err := conn.Query(q, date)
	if err != nil {
		return nil, fmt.Errorf("failed to get receipt numbers by date: %w", err)
	}
	defer rows.Close()

	var numbers []string
	for rows.Next() {
		var number string
		if err = rows.Scan(&number); err != nil { // ここは再宣言ではないので = を使用
			return nil, err
		}
		numbers = append(numbers, number)
	}
	return numbers, nil
}

// GetTransactionsByReceiptNumber returns all transactions for a given receipt number.
func GetTransactionsByReceiptNumber(conn *sql.DB, receiptNumber string) ([]model.TransactionRecord, error) {
	q := `SELECT ` + TransactionColumns + ` FROM transaction_records WHERE receipt_number = ? ORDER BY line_number`
	rows, err := conn.Query(q, receiptNumber)
	if err != nil {
		return nil, fmt.Errorf("failed to get transactions by receipt number: %w", err)
	}
	defer rows.Close()

	var records []model.TransactionRecord
	for rows.Next() {
		r, err := ScanTransactionRecord(rows)
		if err != nil {
			return nil, err
		}
		records = append(records, *r)
	}
	return records, nil
}

// GetProvisionalTransactions retrieves all records marked as 'provisional'.
func GetProvisionalTransactions(tx *sql.Tx) ([]model.TransactionRecord, error) {
	q := `SELECT ` + TransactionColumns + ` FROM transaction_records WHERE processing_status = 'provisional'`
	rows, err := tx.Query(q)
	if err != nil {
		return nil, fmt.Errorf("failed to get provisional transactions: %w", err)
	}
	defer rows.Close()

	var records []model.TransactionRecord
	for rows.Next() {
		r, err := ScanTransactionRecord(rows)
		if err != nil {
			return nil, err
		}
		records = append(records, *r)
	}
	return records, nil
}

// UpdateFullTransactionInTx updates an existing transaction record with enriched master data.
func UpdateFullTransactionInTx(tx *sql.Tx, record *model.TransactionRecord) error {
	const q = `
		UPDATE transaction_records SET
			jan_code = ?, yj_code = ?, product_name = ?, kana_name = ?, usage_classification = ?, package_form = ?, 
			package_spec = ?, maker_name = ?, jan_pack_inner_qty = ?, jan_pack_unit_qty = ?, 
			jan_unit_name = ?, jan_unit_code = ?, yj_pack_unit_qty = ?, yj_unit_name = ?,
			unit_price = ?, purchase_price = ?, supplier_wholesale = ?,
			flag_poison = ?, flag_deleterious = ?, flag_narcotic = ?, flag_psychotropic = ?,
			flag_stimulant = ?, flag_stimulant_raw = ?,
			process_flag_ma = ?, processing_status = ?
		WHERE id = ?`

	_, err := tx.Exec(q,
		record.JanCode, record.YjCode, record.ProductName, record.KanaName, record.UsageClassification, record.PackageForm,
		record.PackageSpec, record.MakerName, record.JanPackInnerQty, record.JanPackUnitQty,
		record.JanUnitName, record.JanUnitCode, record.YjPackUnitQty, record.YjUnitName,
		record.UnitPrice, record.PurchasePrice, record.SupplierWholesale,
		record.FlagPoison, record.FlagDeleterious, record.FlagNarcotic, record.FlagPsychotropic,
		record.FlagStimulant, record.FlagStimulantRaw,
		record.ProcessFlagMA, record.ProcessingStatus,
		record.ID,
	)
	if err != nil {
		return fmt.Errorf("failed to update transaction ID %d: %w", record.ID, err)
	}
	return nil
}

// DeleteTransactionsByReceiptNumberInTx deletes all transaction records with a given receipt number.
func DeleteTransactionsByReceiptNumberInTx(tx *sql.Tx, receiptNumber string) error {
	const q = `DELETE FROM transaction_records WHERE receipt_number = ?`
	_, err := tx.Exec(q, receiptNumber)
	if err != nil {
		return fmt.Errorf("failed to delete transactions for receipt %s: %w", receiptNumber, err)
	}
	return nil
}

// DeleteTransactionsByFlagAndDate deletes transactions with a specific flag on a specific date.
func DeleteTransactionsByFlagAndDate(tx *sql.Tx, flag int, date string) error {
	const q = `DELETE FROM transaction_records WHERE flag = ? AND transaction_date = ?`
	_, err := tx.Exec(q, flag, date)
	if err != nil {
		return fmt.Errorf("failed to delete transactions for flag %d, date %s: %w", flag, date, err)
	}
	return nil
}

// DeleteUsageTransactionsInDateRange deletes usage transactions (flag=3) in a date range.
func DeleteUsageTransactionsInDateRange(tx *sql.Tx, minDate, maxDate string) error {
	const q = `DELETE FROM transaction_records WHERE flag = 3 AND transaction_date BETWEEN ? AND ?`
	_, err := tx.Exec(q, minDate, maxDate)
	if err != nil {
		return fmt.Errorf("failed to delete usage transactions: %w", err)
	}
	return nil
}


----- C:\Dev\WASABI\deadstock\handler.go -----
// C:\Dev\WASABI\deadstock\handler.go

package deadstock

import (
	"database/sql"
	"encoding/json"
	"net/http"
	"strconv" // ▼▼▼ [修正点] 追加 ▼▼▼
	"wasabi/db"
	"wasabi/model"
)

func GetDeadStockHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		q := r.URL.Query()

		// ▼▼▼ [修正点] coefficientを取得する処理を追加 ▼▼▼
		coefficient, err := strconv.ParseFloat(q.Get("coefficient"), 64)
		if err != nil {
			coefficient = 1.5 // Default value
		}

		filters := model.DeadStockFilters{
			StartDate:        q.Get("startDate"),
			EndDate:          q.Get("endDate"),
			ExcludeZeroStock: q.Get("excludeZeroStock") == "true",
			Coefficient:      coefficient,
		}
		// ▲▲▲ 修正ここまで ▲▲▲

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		results, err := db.GetDeadStockList(tx, filters)
		if err != nil {
			http.Error(w, "Failed to get dead stock list: "+err.Error(), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(results)
	}
}

// (SaveDeadStockHandler is unchanged)
func SaveDeadStockHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var payload []model.DeadStockRecord
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, "Invalid request body: "+err.Error(), http.StatusBadRequest)
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		if err := db.UpsertDeadStockRecordsInTx(tx, payload); err != nil {
			http.Error(w, "Failed to save dead stock records: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "保存しました。"})
	}
}


----- C:\Dev\WASABI\inout\handler.go -----
// C:\Dev\WASABI\inout\handler.go

package inout

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"time"
	"wasabi/db"
	"wasabi/mappers"
	"wasabi/mastermanager"
	"wasabi/model"
)

// SaveRecordInput defines the minimal structure for a line item from the frontend.
type SaveRecordInput struct {
	ProductCode string  `json:"productCode"`
	ProductName string  `json:"productName"` // Used as a fallback for mastermanager
	JanQuantity float64 `json:"janQuantity"`
	DatQuantity float64 `json:"datQuantity"` // 「個数」フィールドを追加
	ExpiryDate  string  `json:"expiryDate"`
	LotNumber   string  `json:"lotNumber"`
}

// SavePayload defines the structure for the entire JSON payload from the frontend.
type SavePayload struct {
	IsNewClient           bool              `json:"isNewClient"`
	ClientCode            string            `json:"clientCode"`
	ClientName            string            `json:"clientName"`
	TransactionDate       string            `json:"transactionDate"`
	TransactionType       string            `json:"transactionType"`
	Records               []SaveRecordInput `json:"records"`
	OriginalReceiptNumber string            `json:"originalReceiptNumber"`
}

// SaveInOutHandler processes the saving of an in/out transaction.
func SaveInOutHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var payload SavePayload
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		clientCode := payload.ClientCode
		if payload.IsNewClient {
			exists, err := db.CheckClientExistsByName(tx, payload.ClientName)
			if err != nil {
				http.Error(w, "Failed to check client existence", http.StatusInternalServerError)
				return
			}
			if exists {
				http.Error(w, fmt.Sprintf("Client name '%s' already exists.", payload.ClientName), http.StatusConflict)
				return
			}
			newCode, err := db.NextSequenceInTx(tx, "CL", "CL", 4)
			if err != nil {
				http.Error(w, "Failed to generate new client code", http.StatusInternalServerError)
				return
			}
			if err := db.CreateClientInTx(tx, newCode, payload.ClientName); err != nil {
				http.Error(w, "Failed to create new client", http.StatusInternalServerError)
				return
			}
			clientCode = newCode
		}

		var receiptNumber string
		dateStr := payload.TransactionDate
		if dateStr == "" {
			dateStr = time.Now().Format("20060102")
		}
		if payload.OriginalReceiptNumber != "" {
			receiptNumber = payload.OriginalReceiptNumber
			if err := db.DeleteTransactionsByReceiptNumberInTx(tx, receiptNumber); err != nil {
				http.Error(w, "Failed to delete original slip for update", http.StatusInternalServerError)
				return
			}
		} else {
			var lastSeq int
			q := `SELECT CAST(SUBSTR(receipt_number, 11) AS INTEGER) FROM transaction_records 
				  WHERE receipt_number LIKE ? ORDER BY 1 DESC LIMIT 1`
			err = tx.QueryRow(q, "io"+dateStr+"%").Scan(&lastSeq)
			if err != nil && err != sql.ErrNoRows {
				http.Error(w, "Failed to get last receipt number sequence", http.StatusInternalServerError)
				return
			}
			newSeq := lastSeq + 1
			receiptNumber = fmt.Sprintf("io%s%03d", dateStr, newSeq)
		}

		var finalRecords []model.TransactionRecord
		flagMap := map[string]int{"入庫": 11, "出庫": 12}
		flag := flagMap[payload.TransactionType]

		var keyList, janList []string
		keySet, janSet := make(map[string]struct{}), make(map[string]struct{})
		for _, rec := range payload.Records {
			if rec.ProductCode != "" && rec.ProductCode != "0000000000000" {
				if _, seen := janSet[rec.ProductCode]; !seen {
					janSet[rec.ProductCode] = struct{}{}
					janList = append(janList, rec.ProductCode)
				}
			}
			key := rec.ProductCode
			if key == "" || key == "0000000000000" {
				key = fmt.Sprintf("9999999999999%s", rec.ProductName)
			}
			if _, seen := keySet[key]; !seen {
				keySet[key] = struct{}{}
				keyList = append(keyList, key)
			}
		}

		// ▼▼▼ [修正点] マスター取得をコネクション(conn)ではなくトランザクション(tx)で行う ▼▼▼
		mastersMap, err := db.GetProductMastersByCodesMap(tx, keyList)
		if err != nil {
			http.Error(w, "Failed to pre-fetch product masters", http.StatusInternalServerError)
			return
		}
		jcshmsMap, err := db.GetJcshmsByCodesMap(tx, janList)
		if err != nil {
			http.Error(w, "Failed to pre-fetch JCSHMS data", http.StatusInternalServerError)
			return
		}
		// ▲▲▲ 修正ここまで ▲▲▲

		for i, rec := range payload.Records {
			if rec.ProductCode == "" {
				continue
			}
			master, err := mastermanager.FindOrCreate(tx, rec.ProductCode, rec.ProductName, mastersMap, jcshmsMap)
			if err != nil {
				http.Error(w, fmt.Sprintf("Failed to resolve master for %s: %v", rec.ProductName, err), http.StatusInternalServerError)
				return
			}

			yjQuantity := rec.JanQuantity * master.JanPackInnerQty
			subtotal := yjQuantity * master.NhiPrice

			tr := model.TransactionRecord{
				TransactionDate:  dateStr,
				ClientCode:       clientCode,
				ReceiptNumber:    receiptNumber,
				LineNumber:       fmt.Sprintf("%d", i+1),
				Flag:             flag,
				JanCode:          master.ProductCode,
				JanQuantity:      rec.JanQuantity,
				DatQuantity:      rec.DatQuantity, // 「個数」をセット
				YjQuantity:       yjQuantity,
				Subtotal:         subtotal,
				ExpiryDate:       rec.ExpiryDate,
				LotNumber:        rec.LotNumber,
				ProcessFlagMA:    "COMPLETE",
				ProcessingStatus: sql.NullString{String: "completed", Valid: true},
			}
			mappers.MapProductMasterToTransaction(&tr, master)
			finalRecords = append(finalRecords, tr)
		}

		if len(finalRecords) > 0 {
			if err := db.PersistTransactionRecordsInTx(tx, finalRecords); err != nil {
				log.Printf("Failed to persist records: %v", err)
				http.Error(w, "Failed to save records to database.", http.StatusInternalServerError)
				return
			}
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"message":       "Saved successfully",
			"receiptNumber": receiptNumber,
		})
	}
}


----- C:\Dev\WASABI\inventory\handler.go -----
// C:\Dev\WASABI\inventory\handler.go

package inventory

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"wasabi/db"
	"wasabi/mappers"
	"wasabi/mastermanager"
	"wasabi/model"
	"wasabi/parsers"
)

// insertTransactionQuery defines the SQL statement for inserting transaction records.
const insertTransactionQuery = `
INSERT OR REPLACE INTO transaction_records (
    transaction_date, client_code, receipt_number, line_number, flag,
    jan_code, yj_code, product_name, kana_name, usage_classification, package_form, package_spec, maker_name,
    dat_quantity, jan_pack_inner_qty, jan_quantity, jan_pack_unit_qty, jan_unit_name, jan_unit_code,
    yj_quantity, yj_pack_unit_qty, yj_unit_name, unit_price, purchase_price, supplier_wholesale,
    subtotal, tax_amount, tax_rate, expiry_date, lot_number, flag_poison,
    flag_deleterious, flag_narcotic, flag_psychotropic, flag_stimulant,
    flag_stimulant_raw, process_flag_ma, processing_status
) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)`

// UploadInventoryHandler handles the inventory file upload process.
func UploadInventoryHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var originalJournalMode string
		conn.QueryRow("PRAGMA journal_mode").Scan(&originalJournalMode)

		conn.Exec("PRAGMA journal_mode = MEMORY;")
		conn.Exec("PRAGMA synchronous = OFF;")

		defer func() {
			conn.Exec("PRAGMA synchronous = FULL;")
			conn.Exec(fmt.Sprintf("PRAGMA journal_mode = %s;", originalJournalMode))
			log.Println("Database settings restored for Inventory handler.")
		}()

		file, _, err := r.FormFile("file")
		if err != nil {
			http.Error(w, "File upload error", http.StatusBadRequest)
			return
		}
		defer file.Close()

		parsedData, err := parsers.ParseInventoryFile(file)
		if err != nil {
			http.Error(w, fmt.Sprintf("Failed to parse file: %v", err), http.StatusBadRequest)
			return
		}
		date := parsedData.Date
		if date == "" {
			http.Error(w, "Inventory date not found in file's H record", http.StatusBadRequest)
			return
		}

		recordsToProcess := parsedData.Records
		if len(recordsToProcess) == 0 {
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(map[string]interface{}{
				"message": "No records to process.",
				"details": []model.TransactionRecord{},
			})
			return
		}

		for i := range recordsToProcess {
			recordsToProcess[i].YjQuantity = recordsToProcess[i].JanQuantity * recordsToProcess[i].JanPackInnerQty
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}

		if err := db.DeleteTransactionsByFlagAndDate(tx, 0, date); err != nil { // Flag 0 for inventory
			tx.Rollback()
			http.Error(w, "Failed to delete existing inventory data for date "+date, http.StatusInternalServerError)
			return
		}

		var keyList, janList []string
		keySet, janSet := make(map[string]struct{}), make(map[string]struct{})
		for _, rec := range recordsToProcess {
			if rec.JanCode != "" && rec.JanCode != "0000000000000" {
				if _, seen := janSet[rec.JanCode]; !seen {
					janSet[rec.JanCode] = struct{}{}
					janList = append(janList, rec.JanCode)
				}
			}
			key := rec.JanCode
			if key == "" || key == "0000000000000" {
				key = fmt.Sprintf("9999999999999%s", rec.ProductName)
			}
			if _, seen := keySet[key]; !seen {
				keySet[key] = struct{}{}
				keyList = append(keyList, key)
			}
		}

		// ▼▼▼ [修正点] マスター取得をコネクション(conn)ではなくトランザクション(tx)で行う ▼▼▼
		mastersMap, err := db.GetProductMastersByCodesMap(tx, keyList)
		if err != nil {
			tx.Rollback()
			http.Error(w, "Failed to pre-fetch product masters", http.StatusInternalServerError)
			return
		}
		jcshmsMap, err := db.GetJcshmsByCodesMap(tx, janList)
		if err != nil {
			tx.Rollback()
			http.Error(w, "Failed to pre-fetch JCSHMS data", http.StatusInternalServerError)
			return
		}
		// ▲▲▲ 修正ここまで ▲▲▲

		stmt, err := tx.Prepare(insertTransactionQuery)
		if err != nil {
			tx.Rollback()
			http.Error(w, "Failed to prepare statement", http.StatusInternalServerError)
			return
		}
		defer stmt.Close()

		const batchSize = 500
		var finalRecords []model.TransactionRecord
		receiptNumber := fmt.Sprintf("INV%s", date)

		for i, rec := range recordsToProcess {
			tr := model.TransactionRecord{
				Flag: 0, JanCode: rec.JanCode, ProductName: rec.ProductName, YjQuantity: rec.YjQuantity,
				TransactionDate: date, ReceiptNumber: receiptNumber, LineNumber: fmt.Sprintf("%d", i+1),
			}

			master, err := mastermanager.FindOrCreate(tx, rec.JanCode, rec.ProductName, mastersMap, jcshmsMap)
			if err != nil {
				tx.Rollback()
				http.Error(w, fmt.Sprintf("mastermanager failed for jan %s: %v", rec.JanCode, err), http.StatusInternalServerError)
				return
			}

			if master.JanPackInnerQty > 0 {
				tr.JanQuantity = tr.YjQuantity / master.JanPackInnerQty
			}
			mappers.MapProductMasterToTransaction(&tr, master)

			if master.Origin == "JCSHMS" {
				tr.ProcessFlagMA = "COMPLETE"
				tr.ProcessingStatus = sql.NullString{String: "completed", Valid: true}
			} else {
				tr.ProcessFlagMA = "PROVISIONAL"
				tr.ProcessingStatus = sql.NullString{String: "provisional", Valid: true}
			}

			_, err = stmt.Exec(
				tr.TransactionDate, tr.ClientCode, tr.ReceiptNumber, tr.LineNumber, tr.Flag,
				tr.JanCode, tr.YjCode, tr.ProductName, tr.KanaName, tr.UsageClassification, tr.PackageForm, tr.PackageSpec, tr.MakerName,
				tr.DatQuantity, tr.JanPackInnerQty, tr.JanQuantity, tr.JanPackUnitQty, tr.JanUnitName, tr.JanUnitCode,
				tr.YjQuantity, tr.YjPackUnitQty, tr.YjUnitName, tr.UnitPrice, tr.PurchasePrice, tr.SupplierWholesale,
				tr.Subtotal, tr.TaxAmount, tr.TaxRate, tr.ExpiryDate, tr.LotNumber, tr.FlagPoison,
				tr.FlagDeleterious, tr.FlagNarcotic, tr.FlagPsychotropic, tr.FlagStimulant,
				tr.FlagStimulantRaw, tr.ProcessFlagMA, tr.ProcessingStatus,
			)
			if err != nil {
				tx.Rollback()
				http.Error(w, fmt.Sprintf("Failed to insert record for JAN %s: %v", tr.JanCode, err), http.StatusInternalServerError)
				return
			}

			finalRecords = append(finalRecords, tr)

			if (i+1)%batchSize == 0 && i < len(recordsToProcess)-1 {
				if err := tx.Commit(); err != nil {
					log.Printf("transaction commit error (batch): %v", err)
					http.Error(w, "internal server error", http.StatusInternalServerError)
					return
				}
				tx, err = conn.Begin()
				if err != nil {
					http.Error(w, "Failed to begin next transaction", http.StatusInternalServerError)
					return
				}
				stmt, err = tx.Prepare(insertTransactionQuery)
				if err != nil {
					tx.Rollback()
					http.Error(w, "Failed to re-prepare statement", http.StatusInternalServerError)
					return
				}
			}
		}

		if err := tx.Commit(); err != nil {
			log.Printf("transaction commit error (final): %v", err)
			http.Error(w, "internal server error", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"message": fmt.Sprintf("%d件の棚卸データを登録しました。", len(finalRecords)),
			"details": finalRecords,
		})
	}
}


----- C:\Dev\WASABI\inventory\manual_handler.go -----
// C:\Dev\WASABI\inventory\manual_handler.go

package inventory

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
	"wasabi/db"
	"wasabi/mappers"
	"wasabi/model"
)

// ListInventoryProductsHandler returns all product masters for the manual inventory screen.
func ListInventoryProductsHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		products, err := db.GetAllProductMasters(conn)
		if err != nil {
			http.Error(w, "Failed to get product list: "+err.Error(), http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(products)
	}
}

type ManualInventoryRecord struct {
	ProductCode string  `json:"productCode"`
	YjQuantity  float64 `json:"yjQuantity"`
}

type ManualInventoryPayload struct {
	Date    string                  `json:"date"`
	Records []ManualInventoryRecord `json:"records"`
}

// SaveManualInventoryHandler saves the manually entered inventory counts.
func SaveManualInventoryHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var payload ManualInventoryPayload
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		if payload.Date == "" {
			http.Error(w, "Date is required", http.StatusBadRequest)
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		if err := db.DeleteTransactionsByFlagAndDate(tx, 0, payload.Date); err != nil {
			http.Error(w, "Failed to clear old inventory data", http.StatusInternalServerError)
			return
		}

		var productCodes []string
		recordsMap := make(map[string]float64)
		for _, rec := range payload.Records {
			// ▼▼▼ [修正点] 0以下の数量も許容する（マイナス棚卸など） ▼▼▼
			// if rec.YjQuantity != 0 { // この行と対応する閉じ括弧を削除
			productCodes = append(productCodes, rec.ProductCode)
			recordsMap[rec.ProductCode] = rec.YjQuantity
			// } // この行を削除
			// ▲▲▲ 修正ここまで ▲▲▲
		}

		if len(productCodes) == 0 {
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(map[string]string{"message": "保存するデータがありませんでした。"})
			return
		}

		mastersMap, err := db.GetProductMastersByCodesMap(tx, productCodes)
		if err != nil {
			http.Error(w, "Failed to get product masters", http.StatusInternalServerError)
			return
		}

		var finalRecords []model.TransactionRecord
		receiptNumber := fmt.Sprintf("INV%s", payload.Date)

		for i, code := range productCodes {
			master, ok := mastersMap[code]
			if !ok {
				continue
			}

			tr := model.TransactionRecord{
				TransactionDate:  payload.Date,
				Flag:             0, // 0 = Inventory
				JanCode:          master.ProductCode,
				YjQuantity:       recordsMap[code],
				ReceiptNumber:    receiptNumber,
				LineNumber:       fmt.Sprintf("%d", i+1),
				ProcessFlagMA:    "COMPLETE",
				ProcessingStatus: sql.NullString{String: "completed", Valid: true},
			}

			if master.JanPackInnerQty > 0 {
				tr.JanQuantity = tr.YjQuantity / master.JanPackInnerQty
			}

			mappers.MapProductMasterToTransaction(&tr, master)
			finalRecords = append(finalRecords, tr)
		}

		if err := db.PersistTransactionRecordsInTx(tx, finalRecords); err != nil {
			http.Error(w, "Failed to save inventory records", http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": fmt.Sprintf("%d件の棚卸データを保存しました。", len(finalRecords))})
	}
}


----- C:\Dev\WASABI\loader\loader.go -----
package loader

import (
	"database/sql"
	"encoding/csv"
	"fmt"
	"io"
	"os"
	"strconv"
	"strings"

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

// Defines which columns in the master CSVs should be treated as numeric types.
var tableSchemas = map[string]map[int]string{
	"jcshms": {
		44: "real", // JC044
		50: "real", // JC050 (NHI Price)
		61: "int", 62: "int", 63: "int", 64: "int", 65: "int", 66: "int",
	},
	// ▼▼▼ 修正箇所 ▼▼▼
	// 正しい列番号 (JA006は7列目、JA008は9列目) に修正
	"jancode": {
		7: "real", // JA006
		9: "real", // JA008
	},
	// ▲▲▲ 修正箇所 ▲▲▲
}

// InitDatabase creates the schema and loads master data from CSV files.
func InitDatabase(db *sql.DB) error {
	if err := applySchema(db); err != nil {
		return fmt.Errorf("failed to apply schema.sql: %w", err)
	}
	// JANCODE.CSVはヘッダーがあるため、スキップするように修正
	if err := loadCSV(db, "SOU/JCSHMS.CSV", "jcshms", 125, false); err != nil {
		return fmt.Errorf("failed to load JCSHMS.CSV: %w", err)
	}
	if err := loadCSV(db, "SOU/JANCODE.CSV", "jancode", 30, true); err != nil {
		return fmt.Errorf("failed to load JANCODE.CSV: %w", err)
	}
	return nil
}

func applySchema(db *sql.DB) error {
	schema, err := os.ReadFile("schema.sql")
	if err != nil {
		return err
	}
	_, err = db.Exec(string(schema))
	return err
}

// ヘッダーをスキップするための bool 型引数 `skipHeader` を追加
func loadCSV(db *sql.DB, filepath, tablename string, columns int, skipHeader bool) error {
	f, err := os.Open(filepath)
	if err != nil {
		return err
	}
	defer f.Close()

	r := csv.NewReader(transform.NewReader(f, japanese.ShiftJIS.NewDecoder()))
	r.LazyQuotes = true
	r.FieldsPerRecord = -1

	// skipHeaderがtrueの場合、ファイルの最初の行を読み飛ばす
	if skipHeader {
		if _, err := r.Read(); err != nil && err != io.EOF {
			return err
		}
	}

	tx, err := db.Begin()
	if err != nil {
		return err
	}
	defer tx.Rollback()

	placeholders := strings.Repeat("?,", columns-1) + "?"
	stmt, err := tx.Prepare(fmt.Sprintf("INSERT OR REPLACE INTO %s VALUES (%s)", tablename, placeholders))
	if err != nil {
		return err
	}
	defer stmt.Close()

	schema := tableSchemas[tablename]

	for {
		row, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil || len(row) < columns {
			continue
		}

		args := make([]interface{}, columns)
		for i, val := range row[:columns] {
			// キーは1から始まる列番号なので i+1
			if colType, ok := schema[i+1]; ok {
				trimmedVal := strings.TrimSpace(val)
				switch colType {
				case "real":
					num, _ := strconv.ParseFloat(trimmedVal, 64)
					args[i] = num
				case "int":
					num, _ := strconv.ParseInt(trimmedVal, 10, 64)
					args[i] = num
				}
			} else {
				args[i] = val
			}
		}

		if _, err := stmt.Exec(args...); err != nil {
			continue
		}
	}
	return tx.Commit()
}


----- C:\Dev\WASABI\mappers\mappers.go -----
package mappers

import (
	"database/sql"
	"strconv"
	"wasabi/model"
	"wasabi/units"
)

func MapProductMasterToTransaction(ar *model.TransactionRecord, master *model.ProductMaster) {
	if ar.UnitPrice == 0 {
		ar.UnitPrice = master.NhiPrice
	}

	// ▼▼▼ [修正点] JanCodeのコピー処理を追加 ▼▼▼
	ar.JanCode = master.ProductCode
	// ▲▲▲ 修正ここまで ▲▲▲

	ar.YjCode = master.YjCode
	ar.ProductName = master.ProductName
	ar.KanaName = master.KanaName
	ar.MakerName = master.MakerName
	ar.UsageClassification = master.UsageClassification
	ar.PackageForm = master.PackageForm
	ar.PurchasePrice = master.PurchasePrice
	ar.SupplierWholesale = master.SupplierWholesale
	ar.YjPackUnitQty = master.YjPackUnitQty
	ar.JanPackUnitQty = master.JanPackUnitQty
	ar.JanPackInnerQty = master.JanPackInnerQty
	ar.FlagPoison = master.FlagPoison
	ar.FlagDeleterious = master.FlagDeleterious
	ar.FlagNarcotic = master.FlagNarcotic
	ar.FlagPsychotropic = master.FlagPsychotropic
	ar.FlagStimulant = master.FlagStimulant
	ar.FlagStimulantRaw = master.FlagStimulantRaw

	yjUnitName := units.ResolveName(master.YjUnitName)
	janUnitCodeStr := strconv.Itoa(master.JanUnitCode)
	var janUnitName string
	if janUnitCodeStr == "0" || janUnitCodeStr == "" {
		janUnitName = yjUnitName
	} else {
		janUnitName = units.ResolveName(janUnitCodeStr)
	}
	ar.JanUnitName = janUnitName
	ar.YjUnitName = yjUnitName
	ar.JanUnitCode = janUnitCodeStr

	tempJcshms := model.JCShms{
		JC037: master.PackageSpec,
		JC039: master.YjUnitName,
		JC044: master.YjPackUnitQty,
		JA006: sql.NullFloat64{Float64: master.JanPackInnerQty, Valid: true},
		JA008: sql.NullFloat64{Float64: master.JanPackUnitQty, Valid: true},
		JA007: sql.NullString{String: strconv.Itoa(master.JanUnitCode), Valid: true},
	}
	ar.PackageSpec = units.FormatPackageSpec(&tempJcshms)
}


----- C:\Dev\WASABI\masteredit\handler.go -----
package masteredit

import (
	"database/sql"
	"encoding/json"
	"net/http"
	"wasabi/db"
	"wasabi/model"
)

// GetEditableMastersHandler returns a list of editable product masters.
func GetEditableMastersHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		masters, err := db.GetEditableProductMasters(conn)
		if err != nil {
			http.Error(w, "Failed to get editable masters", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(masters)
	}
}

// UpdateMasterHandler updates or inserts a product master record from the edit screen.
func UpdateMasterHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
			return
		}

		var input model.ProductMasterInput
		if err := json.NewDecoder(r.Body).Decode(&input); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		// A product code is mandatory for saving a record.
		if input.ProductCode == "" {
			http.Error(w, "Product Code (JAN) cannot be empty.", http.StatusBadRequest)
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		if err := db.UpsertProductMasterInTx(tx, input); err != nil {
			http.Error(w, "Failed to upsert product master", http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "Saved successfully."})
	}
}


----- C:\Dev\WASABI\mastermanager\mastermanager.go -----
package mastermanager

import (
	"database/sql"
	"fmt"
	"strconv"
	"wasabi/db"
	"wasabi/model"
)

// FindOrCreate は、マスターの特定と作成に関する全てのロジックを集約した関数です。
// 適切なマスターを返すことを保証し、処理中に新しいマスターが作成された場合はメモリマップも更新します。
func FindOrCreate(
	tx *sql.Tx,
	janCode string,
	productName string,
	mastersMap map[string]*model.ProductMaster,
	jcshmsMap map[string]*model.JCShms,
) (*model.ProductMaster, error) {

	// 1. マスター特定用のキーを生成（JANがあればJAN、なければ製品名から合成）
	key := janCode
	isSyntheticKey := false
	if key == "" || key == "0000000000000" {
		key = fmt.Sprintf("9999999999999%s", productName)
		isSyntheticKey = true
	}

	// 2. まずメモリ上のマップを確認
	if master, ok := mastersMap[key]; ok {
		return master, nil // 発見した場合は即座に返す
	}

	// 3. メモリにない場合、JCSHMS経由での作成を試みる (JANコードが存在する場合のみ)
	if !isSyntheticKey {
		if jcshms, ok := jcshmsMap[janCode]; ok && jcshms.JC018 != "" {
			// JCSHMSに情報があった場合、正式なマスターを作成
			yjCode := jcshms.JC009
			if yjCode == "" {
				// YJコードがなければ新規採番
				newYj, err := db.NextSequenceInTx(tx, "MA2Y", "MA2Y", 8)
				if err != nil {
					return nil, fmt.Errorf("failed to get next sequence for jcshms master: %w", err)
				}
				yjCode = newYj
			}

			// JCSHMSデータからProductMasterInputを作成
			input := createMasterInputFromJcshms(janCode, yjCode, jcshms)
			if err := db.CreateProductMasterInTx(tx, input); err != nil {
				return nil, fmt.Errorf("failed to create master from jcshms: %w", err)
			}

			// DB登録後、メモリマップに反映するためのモデルを作成
			newMaster := createMasterModelFromInput(input)
			mastersMap[key] = &newMaster // メモリマップを更新
			return &newMaster, nil
		}
	}

	// 4. JCSHMSに情報がなければ、仮マスターを作成する
	newYj, err := db.NextSequenceInTx(tx, "MA2Y", "MA2Y", 8)
	if err != nil {
		return nil, fmt.Errorf("failed to get next sequence for provisional master: %w", err)
	}

	provisionalInput := model.ProductMasterInput{
		ProductCode: key,
		YjCode:      newYj,
		ProductName: productName,
		Origin:      "PROVISIONAL",
	}
	if err := db.CreateProductMasterInTx(tx, provisionalInput); err != nil {
		return nil, fmt.Errorf("failed to create provisional master: %w", err)
	}

	// DB登録後、メモリマップに反映
	newMaster := createMasterModelFromInput(provisionalInput)
	mastersMap[key] = &newMaster // メモリマップを更新
	return &newMaster, nil
}

// createMasterInputFromJcshms はJCSHMSのデータからDB登録用のProductMasterInputを作成するヘルパー関数です。
func createMasterInputFromJcshms(jan, yj string, jcshms *model.JCShms) model.ProductMasterInput {
	var nhiPrice float64
	if jcshms.JC044 > 0 {
		nhiPrice = jcshms.JC050 / jcshms.JC044
	}

	// ▼▼▼ 修正箇所 ▼▼▼
	// jcshms.JA007.String (文字列) を正しく整数に変換する
	janUnitCodeVal, _ := strconv.Atoi(jcshms.JA007.String)
	// ▲▲▲ 修正箇所 ▲▲▲

	return model.ProductMasterInput{
		ProductCode:         jan,
		YjCode:              yj,
		ProductName:         jcshms.JC018,
		Origin:              "JCSHMS",
		KanaName:            jcshms.JC022,
		MakerName:           jcshms.JC030,
		UsageClassification: jcshms.JC013,
		PackageForm:         jcshms.JC037,
		PackageSpec:         jcshms.JC037,
		YjUnitName:          jcshms.JC039,
		YjPackUnitQty:       jcshms.JC044,
		FlagPoison:          jcshms.JC061,
		FlagDeleterious:     jcshms.JC062,
		FlagNarcotic:        jcshms.JC063,
		FlagPsychotropic:    jcshms.JC064,
		FlagStimulant:       jcshms.JC065,
		FlagStimulantRaw:    jcshms.JC066,
		JanPackInnerQty:     jcshms.JA006.Float64,
		JanUnitCode:         janUnitCodeVal, // 修正した値を正しくセットする
		JanPackUnitQty:      jcshms.JA008.Float64,
		NhiPrice:            nhiPrice,
	}
}

// createMasterModelFromInput はDB登録用のInputからメモリマップ格納用のProductMasterを作成するヘルパー関数です。
func createMasterModelFromInput(input model.ProductMasterInput) model.ProductMaster {
	return model.ProductMaster{
		ProductCode:         input.ProductCode,
		YjCode:              input.YjCode,
		ProductName:         input.ProductName,
		Origin:              input.Origin,
		KanaName:            input.KanaName,
		MakerName:           input.MakerName,
		UsageClassification: input.UsageClassification,
		PackageForm:         input.PackageForm,
		PackageSpec:         input.PackageSpec,
		YjUnitName:          input.YjUnitName,
		YjPackUnitQty:       input.YjPackUnitQty,
		FlagPoison:          input.FlagPoison,
		FlagDeleterious:     input.FlagDeleterious,
		FlagNarcotic:        input.FlagNarcotic,
		FlagPsychotropic:    input.FlagPsychotropic,
		FlagStimulant:       input.FlagStimulant,
		FlagStimulantRaw:    input.FlagStimulantRaw,
		JanPackInnerQty:     input.JanPackInnerQty,
		JanUnitCode:         input.JanUnitCode,
		JanPackUnitQty:      input.JanPackUnitQty,
		NhiPrice:            input.NhiPrice,
		PurchasePrice:       input.PurchasePrice,
		SupplierWholesale:   input.SupplierWholesale,
	}
}


----- C:\Dev\WASABI\medrec\handler.go -----
// C:\Dev\WASABI\medrec\handler.go

package medrec

import (
	"bytes"
	"database/sql"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"mime"
	"net/http"
	"net/http/cookiejar"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"time"
	"wasabi/config"
)

// DownloadHandler handles the entire process of logging into e-mednet and downloading the DAT file.
func DownloadHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		cfg, err := config.LoadConfig()
		if err != nil {
			http.Error(w, "設定ファイルの読み込みに失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}
		if cfg.EmednetUserID == "" || cfg.EmednetPassword == "" {
			http.Error(w, "e-mednetのIDまたはパスワードが設定されていません。設定画面を確認してください。", http.StatusBadRequest)
			return
		}

		jar, _ := cookiejar.New(nil)
		client := &http.Client{Jar: jar}

		loginURL := "https://www.e-mednet.jp/NASApp/ASP/MenuMain"
		loginData := url.Values{}
		// ▼▼▼ [修正点] HTMLのフォーム名と完全に一致させる ▼▼▼
		loginData.Set("userid", cfg.EmednetUserID)
		loginData.Set("userpsw", cfg.EmednetPassword)
		// ▲▲▲ 修正ここまで ▲▲▲
		loginData.Set("loginkbn", "login")

		loginReq, _ := http.NewRequest("POST", loginURL, strings.NewReader(loginData.Encode()))
		loginReq.Header.Add("Content-Type", "application/x-www-form-urlencoded")

		loginResp, err := client.Do(loginReq)
		if err != nil {
			http.Error(w, "e-mednetへのログインリクエストに失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}
		defer loginResp.Body.Close()

		bodyBytes, err := io.ReadAll(loginResp.Body)
		if err != nil {
			http.Error(w, "e-mednetからのレスポンス読み込みに失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}
		loginResp.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))

		if loginResp.StatusCode != http.StatusOK || strings.Contains(string(bodyBytes), "ログインＩＤまたはパスワードに誤りがあります") {
			log.Printf("e-mednet login failed. Server response:\n---\n%s\n---", string(bodyBytes))
			http.Error(w, fmt.Sprintf("e-mednetへのログインに失敗しました。ID/パスワードを確認するか、サイトの仕様が変更された可能性があります。"), http.StatusUnauthorized)
			return
		}
		log.Println("e-mednet login successful.")

		downloadURL := "https://www.e-mednet.jp/NASApp/ASP/SrDeliveryJanDownload/downloadAll"
		downloadData := url.Values{}
		downloadData.Set("busi_id", "11")
		downloadData.Set("func_id", "02")
		downloadData.Set("sys", "310")
		downloadData.Set("ver", "1.00")
		downloadData.Set("type", "1")

		downloadReq, _ := http.NewRequest("POST", downloadURL, strings.NewReader(downloadData.Encode()))
		downloadReq.Header.Add("Content-Type", "application/x-www-form-urlencoded")

		downloadResp, err := client.Do(downloadReq)
		if err != nil {
			http.Error(w, "ダウンロードリクエストに失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}
		defer downloadResp.Body.Close()
		log.Println("e-mednet download request successful.")

		baseDir := filepath.Join("download", "DAT")
		if err := os.MkdirAll(baseDir, 0755); err != nil {
			http.Error(w, "ベースディレクトリの作成に失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}

		timestamp := time.Now().Format("20060102150405")
		saveDir := filepath.Join(baseDir, timestamp)
		if err := os.MkdirAll(saveDir, 0755); err != nil {
			http.Error(w, "タイムスタンプディレクトリの作成に失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}

		filename := "納品データ.DAT"
		contentDisposition := downloadResp.Header.Get("Content-Disposition")
		if contentDisposition != "" {
			_, params, err := mime.ParseMediaType(contentDisposition)
			if err == nil {
				if f, ok := params["filename"]; ok {
					filename = f
				}
			}
		}

		fullPath := filepath.Join(saveDir, filename)

		fileBytes, err := io.ReadAll(downloadResp.Body)
		if err != nil {
			http.Error(w, "ダウンロードデータの読み込みに失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if err := os.WriteFile(fullPath, fileBytes, 0644); err != nil {
			http.Error(w, "ファイル保存に失敗しました: "+err.Error(), http.StatusInternalServerError)
			return
		}
		log.Printf("File saved to %s", fullPath)

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"message": fmt.Sprintf("ファイルを %s に保存しました。", fullPath),
		})
	}
}


----- C:\Dev\WASABI\model\types.go -----
// C:\Dev\WASABI\model\types.go

package model

import "database/sql"

// (Struct definitions up to DeadStockFilters are unchanged)
type ProductMaster struct {
	ProductCode         string  `json:"productCode"`
	YjCode              string  `json:"yjCode"`
	ProductName         string  `json:"productName"`
	Origin              string  `json:"origin"`
	KanaName            string  `json:"kanaName"`
	MakerName           string  `json:"makerName"`
	UsageClassification string  `json:"usageClassification"`
	PackageForm         string  `json:"packageForm"`
	PackageSpec         string  `json:"packageSpec"`
	YjUnitName          string  `json:"yjUnitName"`
	YjPackUnitQty       float64 `json:"yjPackUnitQty"`
	FlagPoison          int     `json:"flagPoison"`
	FlagDeleterious     int     `json:"flagDeleterious"`
	FlagNarcotic        int     `json:"flagNarcotic"`
	FlagPsychotropic    int     `json:"flagPsychotropic"`
	FlagStimulant       int     `json:"flagStimulant"`
	FlagStimulantRaw    int     `json:"flagStimulantRaw"`
	JanPackInnerQty     float64 `json:"janPackInnerQty"`
	JanUnitCode         int     `json:"janUnitCode"`
	JanPackUnitQty      float64 `json:"janPackUnitQty"`
	NhiPrice            float64 `json:"nhiPrice"`
	PurchasePrice       float64 `json:"purchasePrice"`
	SupplierWholesale   string  `json:"supplierWholesale"`
}
type ProductMasterInput struct {
	ProductCode         string  `json:"productCode"`
	YjCode              string  `json:"yjCode"`
	ProductName         string  `json:"productName"`
	Origin              string  `json:"origin"`
	KanaName            string  `json:"kanaName"`
	MakerName           string  `json:"makerName"`
	UsageClassification string  `json:"usageClassification"`
	PackageForm         string  `json:"packageForm"`
	PackageSpec         string  `json:"packageSpec"`
	YjUnitName          string  `json:"yjUnitName"`
	YjPackUnitQty       float64 `json:"yjPackUnitQty"`
	FlagPoison          int     `json:"flagPoison"`
	FlagDeleterious     int     `json:"flagDeleterious"`
	FlagNarcotic        int     `json:"flagNarcotic"`
	FlagPsychotropic    int     `json:"flagPsychotropic"`
	FlagStimulant       int     `json:"flagStimulant"`
	FlagStimulantRaw    int     `json:"flagStimulantRaw"`
	JanPackInnerQty     float64 `json:"janPackInnerQty"`
	JanUnitCode         int     `json:"janUnitCode"`
	JanPackUnitQty      float64 `json:"janPackUnitQty"`
	NhiPrice            float64 `json:"nhiPrice"`
	PurchasePrice       float64 `json:"purchasePrice"`
	SupplierWholesale   string  `json:"supplierWholesale"`
}
type JCShms struct {
	JC009 string
	JC013 string
	JC018 string
	JC022 string
	JC030 string
	JC037 string
	JC039 string
	JC044 float64
	JC050 float64
	JC061 int
	JC062 int
	JC063 int
	JC064 int
	JC065 int
	JC066 int
	JA006 sql.NullFloat64
	JA007 sql.NullString
	JA008 sql.NullFloat64
}
type TransactionRecord struct {
	ID                  int            `json:"id"`
	TransactionDate     string         `json:"transactionDate"`
	ClientCode          string         `json:"clientCode"`
	ReceiptNumber       string         `json:"receiptNumber"`
	LineNumber          string         `json:"lineNumber"`
	Flag                int            `json:"flag"`
	JanCode             string         `json:"janCode"`
	YjCode              string         `json:"yjCode"`
	ProductName         string         `json:"productName"`
	KanaName            string         `json:"kanaName"`
	UsageClassification string         `json:"usageClassification"`
	PackageForm         string         `json:"packageForm"`
	PackageSpec         string         `json:"packageSpec"`
	MakerName           string         `json:"makerName"`
	DatQuantity         float64        `json:"datQuantity"`
	JanPackInnerQty     float64        `json:"janPackInnerQty"`
	JanQuantity         float64        `json:"janQuantity"`
	JanPackUnitQty      float64        `json:"janPackUnitQty"`
	JanUnitName         string         `json:"janUnitName"`
	JanUnitCode         string         `json:"janUnitCode"`
	YjQuantity          float64        `json:"yjQuantity"`
	YjPackUnitQty       float64        `json:"yjPackUnitQty"`
	YjUnitName          string         `json:"yjUnitName"`
	UnitPrice           float64        `json:"unitPrice"`
	PurchasePrice       float64        `json:"purchasePrice"`
	SupplierWholesale   string         `json:"supplierWholesale"`
	Subtotal            float64        `json:"subtotal"`
	TaxAmount           float64        `json:"taxAmount"`
	TaxRate             float64        `json:"taxRate"`
	ExpiryDate          string         `json:"expiryDate"`
	LotNumber           string         `json:"lotNumber"`
	FlagPoison          int            `json:"flagPoison"`
	FlagDeleterious     int            `json:"flagDeleterious"`
	FlagNarcotic        int            `json:"flagNarcotic"`
	FlagPsychotropic    int            `json:"flagPsychotropic"`
	FlagStimulant       int            `json:"flagStimulant"`
	FlagStimulantRaw    int            `json:"flagStimulantRaw"`
	ProcessFlagMA       string         `json:"processFlagMA"`
	ProcessingStatus    sql.NullString `json:"processingStatus"`
}

func (t *TransactionRecord) SignedYjQty() float64 {
	switch t.Flag {
	case 1, 4, 11:
		return t.YjQuantity
	case 2, 3, 5, 12:
		return -t.YjQuantity
	default:
		return 0
	}
}
func (t *TransactionRecord) ToProductMaster() *ProductMaster {
	return &ProductMaster{
		ProductCode:         t.JanCode,
		YjCode:              t.YjCode,
		ProductName:         t.ProductName,
		KanaName:            t.KanaName,
		UsageClassification: t.UsageClassification,
		PackageForm:         t.PackageForm,
		JanPackInnerQty:     t.JanPackInnerQty,
		YjUnitName:          t.YjUnitName,
	}
}

type ProductMasterView struct {
	ProductMaster
	FormattedPackageSpec string `json:"formattedPackageSpec"`
}
type Client struct {
	Code string `json:"code"`
	Name string `json:"name"`
}
type AggregationFilters struct {
	StartDate   string
	EndDate     string
	KanaName    string
	DrugTypes   []string
	DosageForm  string
	Coefficient float64
}
type StockLedgerYJGroup struct {
	YjCode            string                    `json:"yjCode"`
	ProductName       string                    `json:"productName"`
	YjUnitName        string                    `json:"yjUnitName"`
	PackageLedgers    []StockLedgerPackageGroup `json:"packageLedgers"`
	StartingBalance   interface{}               `json:"startingBalance"`
	NetChange         float64                   `json:"netChange"`
	EndingBalance     interface{}               `json:"endingBalance"`
	TotalReorderPoint float64                   `json:"totalReorderPoint"`
	IsReorderNeeded   bool                      `json:"isReorderNeeded"`
}
type StockLedgerPackageGroup struct {
	PackageKey      string              `json:"packageKey"`
	JanUnitName     string              `json:"janUnitName"`
	StartingBalance interface{}         `json:"startingBalance"`
	Transactions    []LedgerTransaction `json:"transactions"`
	NetChange       float64             `json:"netChange"`
	EndingBalance   interface{}         `json:"endingBalance"`
	MaxUsage        float64             `json:"maxUsage"`
	ReorderPoint    float64             `json:"reorderPoint"`
	IsReorderNeeded bool                `json:"isReorderNeeded"`
	Master          *ProductMaster      `json:"-"`
}
type LedgerTransaction struct {
	TransactionRecord
	RunningBalance float64 `json:"runningBalance"`
}
type UnifiedInputRecord struct {
	Date            string  `json:"date"`
	JanCode         string  `json:"janCode"`
	YjCode          string  `json:"yjCode"`
	ProductName     string  `json:"productName"`
	DatQuantity     float64 `json:"datQuantity"`
	JanPackInnerQty float64 `json:"janPackInnerQty"`
	JanQuantity     float64 `json:"janQuantity"`
	YjQuantity      float64 `json:"yjQuantity"`
	YjUnitName      string  `json:"yjUnitName"`
	ClientCode      string  `json:"clientCode"`
	ReceiptNumber   string  `json:"receiptNumber"`
	LineNumber      string  `json:"lineNumber"`
	Flag            int     `json:"flag"`
	UnitPrice       float64 `json:"unitPrice"`
	Subtotal        float64 `json:"subtotal"`
	ExpiryDate      string  `json:"expiryDate"`
	LotNumber       string  `json:"lotNumber"`
}
type DeadStockGroup struct {
	YjCode      string             `json:"yjCode"`
	ProductName string             `json:"productName"`
	TotalStock  float64            `json:"totalStock"`
	Packages    []DeadStockPackage `json:"packages"`
}
type DeadStockPackage struct {
	ProductMaster
	CurrentStock float64           `json:"currentStock"`
	SavedRecords []DeadStockRecord `json:"savedRecords"`
}
type DeadStockRecord struct {
	ID               int     `json:"id"`
	ProductCode      string  `json:"productCode"`
	YjCode           string  `json:"yjCode"`
	PackageForm      string  `json:"packageForm"`
	JanPackInnerQty  float64 `json:"janPackInnerQty"`
	YjUnitName       string  `json:"yjUnitName"`
	StockQuantityJan float64 `json:"stockQuantityJan"`
	ExpiryDate       string  `json:"expiryDate"`
	LotNumber        string  `json:"lotNumber"`
}

// ▼▼▼ [修正点] DeadStockFiltersにCoefficientを追加 ▼▼▼
type DeadStockFilters struct {
	StartDate        string
	EndDate          string
	ExcludeZeroStock bool
	Coefficient      float64
}

// ▲▲▲ 修正ここまで ▲▲▲


----- C:\Dev\WASABI\parsers\dat_parser.go -----
package parsers

import (
	"bufio"
	"io"
	"strconv"
	"strings"
	"wasabi/model"

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

// ParseDatは、固定長のDATファイルからレコードを抽出し、UnifiedInputRecordのスライスを返します。
func ParseDat(r io.Reader) ([]model.UnifiedInputRecord, error) {
	scanner := bufio.NewScanner(r)
	var records []model.UnifiedInputRecord
	var currentWholesale string

	for scanner.Scan() {
		line := scanner.Text()
		if len(line) == 0 {
			continue
		}

		switch line[0:1] {
		case "S":
			if len(line) >= 13 {
				currentWholesale = strings.TrimSpace(line[2:13])
			}
		case "D":
			if len(line) < 121 {
				line += strings.Repeat(" ", 121-len(line))
			}

			// 型変換をここで行う
			productNameSJIS := line[38:78]
			utf8Bytes, _, _ := transform.Bytes(japanese.ShiftJIS.NewDecoder(), []byte(productNameSJIS))

			flag, _ := strconv.Atoi(strings.TrimSpace(line[3:4]))
			datqty, _ := strconv.ParseFloat(strings.TrimSpace(line[78:83]), 64)
			unitprice, _ := strconv.ParseFloat(strings.TrimSpace(line[83:92]), 64)
			subtotal, _ := strconv.ParseFloat(strings.TrimSpace(line[92:101]), 64)

			// UnifiedInputRecordを直接構築
			rec := model.UnifiedInputRecord{
				ClientCode:    currentWholesale,
				Flag:          flag,
				Date:          strings.TrimSpace(line[4:12]),
				ReceiptNumber: strings.TrimSpace(line[12:22]),
				LineNumber:    strings.TrimSpace(line[22:24]),
				JanCode:       strings.TrimSpace(line[25:38]),
				ProductName:   strings.TrimSpace(string(utf8Bytes)),
				DatQuantity:   datqty,
				UnitPrice:     unitprice,
				Subtotal:      subtotal,
				ExpiryDate:    strings.TrimSpace(line[109:115]), // 文字列として直接格納
				LotNumber:     strings.TrimSpace(line[115:121]),
			}
			records = append(records, rec)
		}
	}
	return records, scanner.Err()
}


----- C:\Dev\WASABI\parsers\inventory_parser.go -----
package parsers

import (
	"encoding/csv"
	"fmt"
	"io"
	"strconv"
	"strings"
	"wasabi/model"

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

// ParsedInventoryDataはファイル全体の構造体です
type ParsedInventoryData struct {
	Date    string
	Records []model.UnifiedInputRecord
}

// trimQuotesは文字列から空白とシングルクォートを除去します
func trimQuotes(s string) string {
	return strings.Trim(strings.TrimSpace(s), "'")
}

// ParseInventoryFileは棚卸ファイルを解析し、UnifiedInputRecordのスライスを返します
func ParseInventoryFile(r io.Reader) (*ParsedInventoryData, error) {
	decoder := japanese.ShiftJIS.NewDecoder()
	reader := csv.NewReader(transform.NewReader(r, decoder))
	reader.FieldsPerRecord = -1

	var result ParsedInventoryData
	var dataRecords []model.UnifiedInputRecord

	records, err := reader.ReadAll()
	if err != nil {
		return nil, fmt.Errorf("csv read all error: %w", err)
	}

	for _, row := range records {
		if len(row) == 0 {
			continue
		}

		rowType := strings.TrimSpace(row[0])
		switch rowType {
		case "H":
			if len(row) > 4 {
				result.Date = trimQuotes(row[4])
			}
		case "R1":
			if len(row) > 45 {
				innerPackQty, _ := strconv.ParseFloat(strings.TrimSpace(row[17]), 64)
				physicalJanQty, _ := strconv.ParseFloat(strings.TrimSpace(row[21]), 64)

				dataRecords = append(dataRecords, model.UnifiedInputRecord{
					ProductName:     trimQuotes(row[12]),
					YjUnitName:      trimQuotes(row[16]),
					JanPackInnerQty: innerPackQty,   // 18列目を格納
					JanQuantity:     physicalJanQty, // 22列目を格納
					YjCode:          trimQuotes(row[42]),
					JanCode:         trimQuotes(row[45]),
				})
			}
		}
	}
	result.Records = dataRecords
	return &result, nil
}


----- C:\Dev\WASABI\parsers\usage_parser.go -----
package parsers

import (
	"encoding/csv"
	"fmt"
	"io"
	"strconv"
	"wasabi/model"

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

// ParseUsageはUSAGE CSVを解析し、UnifiedInputRecordのスライスを返します。
func ParseUsage(r io.Reader) ([]model.UnifiedInputRecord, error) {
	reader := csv.NewReader(transform.NewReader(r, japanese.ShiftJIS.NewDecoder()))
	reader.FieldsPerRecord = -1

	var records []model.UnifiedInputRecord
	for {
		rec, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			return nil, fmt.Errorf("csv read error: %w", err)
		}

		if len(rec) < 6 {
			continue // skip incomplete rows
		}

		yjQty, _ := strconv.ParseFloat(rec[4], 64)

		unifiedRec := model.UnifiedInputRecord{
			Date:        rec[0],
			YjCode:      rec[1],
			JanCode:     rec[2],
			ProductName: rec[3],
			YjQuantity:  yjQty,
			YjUnitName:  rec[5],
		}
		records = append(records, unifiedRec)
	}
	return records, nil
}


----- C:\Dev\WASABI\reprocess\handler.go -----
// C:\Dev\WASABI\reprocess\handler.go

package reprocess

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
	"wasabi/db"
	"wasabi/mappers"
)

// ▼▼▼ [修正点] ロジック全体を書き換え、デッドロックを解消 ▼▼▼
func ReProcessTransactionsHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// 1. 最初にトランザクションを開始
		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction: "+err.Error(), http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		// 2. トランザクション内で、更新対象のリストを取得
		provisionalRecords, err := db.GetProvisionalTransactions(tx)
		if err != nil {
			http.Error(w, "Failed to fetch provisional records: "+err.Error(), http.StatusInternalServerError)
			return
		}
		if len(provisionalRecords) == 0 {
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(map[string]string{"message": "更新対象の仮登録データはありませんでした。"})
			return
		}

		// 3. トランザクション内で、関連マスターを一括取得
		keyList := make([]string, 0, len(provisionalRecords))
		keySet := map[string]struct{}{}
		for _, rec := range provisionalRecords {
			key := rec.JanCode
			if key == "" || key == "0000000000000" {
				key = fmt.Sprintf("9999999999999%s", rec.ProductName)
			}
			if _, seen := keySet[key]; !seen {
				keySet[key] = struct{}{}
				keyList = append(keyList, key)
			}
		}
		mastersMap, err := db.GetProductMastersByCodesMap(tx, keyList)
		if err != nil {
			http.Error(w, "Failed to load product masters: "+err.Error(), http.StatusInternalServerError)
			return
		}

		// 4. 一件ずつマッピング＆更新
		updatedCount := 0
		for _, rec := range provisionalRecords {
			key := rec.JanCode
			if key == "" || key == "0000000000000" {
				key = fmt.Sprintf("9999999999999%s", rec.ProductName)
			}
			master, ok := mastersMap[key]

			if !ok || master.Origin == "PROVISIONAL" {
				continue
			}

			mappers.MapProductMasterToTransaction(&rec, master)
			// 再計算なので、ステータスをCOMPLETEに変更
			rec.ProcessFlagMA = "COMPLETE"
			rec.ProcessingStatus = sql.NullString{String: "completed", Valid: true}

			if err := db.UpdateFullTransactionInTx(tx, &rec); err != nil {
				http.Error(w, fmt.Sprintf("Failed to update record ID %d: %v", rec.ID, err), http.StatusInternalServerError)
				return
			}
			updatedCount++
		}

		// 5. コミットして完了
		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit: "+err.Error(), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"message": fmt.Sprintf("%d 件の仮登録データを再計算しました。", updatedCount),
		})
	}
}

// ▲▲▲ 修正ここまで ▲▲▲


----- C:\Dev\WASABI\settings\handler.go -----
// C:\Dev\WASABI\settings\handler.go

package settings

import (
	"database/sql"
	"encoding/json"
	"net/http"
	"wasabi/config"
)

// GetSettingsHandler returns the current settings.
func GetSettingsHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		cfg, err := config.LoadConfig()
		if err != nil {
			http.Error(w, "Failed to load settings: "+err.Error(), http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(cfg)
	}
}

// SaveSettingsHandler saves the settings.
func SaveSettingsHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var payload config.Config
		if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		if err := config.SaveConfig(payload); err != nil {
			http.Error(w, "Failed to save settings: "+err.Error(), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "設定を保存しました。"})
	}
}


----- C:\Dev\WASABI\static\css\inout.css -----
.inout-view-container {
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.inout-header-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 10px 16px;
    padding: 16px;
    border: 1px solid #000;
    background-color: #f7f7f7;
    align-items: flex-end;
}

.inout-header-controls .field-group {
    display: flex;
    flex-direction: column;
    gap: 4px;
}
.inout-header-controls .field-group label {
    font-size: 12px;
    font-weight: bold;
}
.inout-header-controls .field-group input,
.inout-header-controls .field-group select {
    padding: 6px;
    border: 1px solid #000;
    font-size: 14px;
    min-width: 150px;
}
.inout-header-controls .buttons-group {
    display: flex;
    gap: 8px;
    margin-left: auto;
}

.inout-details-header {
    text-align: right;
}

----- C:\Dev\WASABI\static\css\styles.css -----
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: sans-serif; padding: 10px; background-color: #f4f4f4; }
.hidden { display: none !important; }

header { display: flex; align-items: center; gap: 8px; padding: 10px; border-bottom: 2px solid #ccc; margin-bottom: 15px; background-color: #ffffff; }
.btn { font-size: 14px; padding: 8px 12px; background-color: #e9ecef; border: 1px solid #ced4da; border-radius: 4px; cursor: pointer; }
.btn:hover { background-color: #dee2e6; }

table { border-collapse: collapse; width: 100%; table-layout: fixed; }
th, td { border: 1px solid black; padding: 4px; vertical-align: middle; }
th { text-align: center; background-color: #f0f0f0; }
.yj-jan-code { overflow: hidden; white-space: nowrap; text-overflow: ellipsis; }
.left { text-align: left; }
.right { text-align: right; }

.data-table td input[type="text"],
.data-table td input[type="number"] {
    width: 100%;
    border: 1px solid #999;
    padding: 4px;
    font-size: 11pt;
}

#loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 9999; color: white; }
.spinner { border: 5px solid #f3f3f3; border-top: 5px solid #0d6efd; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; margin-bottom: 10px; }
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

.notification-box { position: fixed; top: -100px; left: 50%; transform: translateX(-50%); padding: 15px 25px; border-radius: 5px; color: white; font-size: 16px; z-index: 10000; transition: top 0.5s; }
.notification-box.show { top: 20px; }
.notification-box.success { background-color: #198754; }
.notification-box.error { background-color: #dc3545; }

.modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); display: flex; align-items: center; justify-content: center; z-index: 2000; }
.modal-content { background-color: #ffffff; border: 1px solid #000000; padding: 20px; width: 80%; max-width: 900px; max-height: 90vh; display: flex; flex-direction: column; }
.modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
.modal-header h2 { font-size: 20px; }
.modal-body { overflow-y: auto; }
.close-button { font-size: 24px; border: none; background: none; cursor: pointer; }

.agg-yj-header { background-color: #343a40; color: white; padding: 8px; margin-top: 20px; font-weight: bold; font-size: 16px; display: flex; align-items: center; }
.agg-yj-header .product-name { margin-left: 20px; flex-grow: 1; }
.agg-yj-header .balance-info { font-size: 14px; font-weight: normal; }
.agg-pkg-header { background-color: #e9ecef; padding: 6px 8px; border: 1px solid #ccc; border-bottom: none; font-weight: bold; }



----- C:\Dev\WASABI\static\js\aggregation.js -----
import { transactionTypeMap, createUploadTableHTML, renderUploadTableRows } from './common_table.js';
let view, runBtn, printBtn, outputContainer, startDateInput, endDateInput, kanaNameInput, dosageFormInput, coefficientInput, drugTypeCheckboxes, reorderNeededCheckbox;
let lastData = []; // サーバーから受け取った元のデータを保持

/**
 * 在庫数をフォーマットするヘルパー関数
 * @param {number | string} balance - 在庫数（数値または "期間棚卸なし" の文字列）
 * @returns {string} 表示用にフォーマットされた文字列
 */
function formatBalance(balance) {
    // 渡された値が数値の場合のみ、小数点以下2桁にフォーマットする
    if (typeof balance === 'number') {
        return balance.toFixed(2);
    }
    // 文字列（"期間棚卸なし" など）の場合は、そのまま返す
    return balance;
}

function renderResults() {
    let dataToRender = lastData; // 「不足品のみ表示」フィルターを適用
    if (reorderNeededCheckbox.checked) {
        dataToRender = lastData.filter(yjGroup => yjGroup.isReorderNeeded)
            .map(yjGroup => ({
                ...yjGroup,
                packageLedgers: yjGroup.packageLedgers.filter(pkg => pkg.isReorderNeeded)
            }));
    }

    if (!dataToRender || dataToRender.length === 0) {
        outputContainer.innerHTML = "<p>対象データが見つかりませんでした。</p>";
        return;
    }

    let html = '';
    dataToRender.forEach((yjGroup, yjIndex) => {
        // formatBalance ヘルパー関数を使用して、数値・文字列の両方に対応
        html += `
            <div class="agg-yj-header" ${yjGroup.isReorderNeeded ? 'style="background-color: #f8d7da;"' : ''}>
                <span>YJ: ${yjGroup.yjCode}</span>
                <span class="product-name">${yjGroup.productName}</span>
                <span class="balance-info">
                    在庫: ${formatBalance(yjGroup.endingBalance)} | 
                    発注点: ${formatBalance(yjGroup.totalReorderPoint)} | 
                    変動: ${formatBalance(yjGroup.netChange)}
                </span>
            </div>
        `;
     
        yjGroup.packageLedgers.forEach((pkg, pkgIndex) => {
            const tableId = `agg-table-${yjIndex}-${pkgIndex}`;
            // formatBalance ヘルパー関数を使用して、数値・文字列の両方に対応
            html += `
                <div class="agg-pkg-header" ${pkg.isReorderNeeded ? 'style="background-color: #fff3cd;"' : ''}>
                    <span>包装: ${pkg.packageKey}</span>
                    <span class="balance-info">
                        在庫: ${formatBalance(pkg.endingBalance)} |
                        発注点: ${formatBalance(pkg.reorderPoint)} | 
                        変動: ${formatBalance(pkg.netChange)}
                    </span>
                </div>
                <div id="${tableId}-container"></div>`;
        });
    });
    outputContainer.innerHTML = html;

    dataToRender.forEach((yjGroup, yjIndex) => {
        yjGroup.packageLedgers.forEach((pkg, pkgIndex) => {
            const tableId = `agg-table-${yjIndex}-${pkgIndex}`;
            const container = document.getElementById(`${tableId}-container`);
            if (container) {
                container.innerHTML = createUploadTableHTML(tableId);
                renderUploadTableRows(tableId, pkg.transactions);
            }
        });
    });
}

export function initAggregation() {
    view = document.getElementById('aggregation-view');
    if (!view) return; // 新しいフィルター要素を取得
    runBtn = document.getElementById('run-aggregation-btn');
    printBtn = document.getElementById('print-aggregation-btn');
    outputContainer = document.getElementById('aggregation-output-container');
    startDateInput = document.getElementById('startDate');
    endDateInput = document.getElementById('endDate');
    kanaNameInput = document.getElementById('kanaName');
    dosageFormInput = document.getElementById('dosageForm');
    coefficientInput = document.getElementById('reorder-coefficient');
    drugTypeCheckboxes = document.querySelectorAll('input[name="drugType"]');
    reorderNeededCheckbox = document.getElementById('reorder-needed-filter'); // 日付のデフォルト値を設定
    const today = new Date();
    const threeMonthsAgo = new Date(today.getFullYear(), today.getMonth() - 3, today.getDate());
    endDateInput.value = today.toISOString().slice(0, 10);
    startDateInput.value = threeMonthsAgo.toISOString().slice(0, 10);

    printBtn.addEventListener('click', () => window.print());
    reorderNeededCheckbox.addEventListener('change', () => renderResults());
    runBtn.addEventListener('click', async () => {
        window.showLoading();

        const selectedDrugTypes = Array.from(drugTypeCheckboxes)
            .filter(cb => cb.checked)
            .map(cb => cb.value)
            .join(',');

        const params = new URLSearchParams({
            startDate: startDateInput.value.replace(/-/g, ''),
            endDate: endDateInput.value.replace(/-/g, ''),
            kanaName: kanaNameInput.value,
            dosageForm: dosageFormInput.value,
            coefficient: coefficientInput.value,
            drugTypes: selectedDrugTypes,
        });

        try {
            const res = await fetch(`/api/aggregation?${params.toString()}`);
            if (!res.ok) {
                const errText = await res.text();
                throw new Error(errText || 'Aggregation failed');
            }
            lastData = await res.json(); // 元データを保持

         renderResults();       // ← 既存：DOM 更新
         // ← DOM 更新後、次のペイント直前に発火するカスタムイベント
        requestAnimationFrame(() => {
        window.dispatchEvent(new Event('aggregationRendered'));
        });

        } catch (err) {
            outputContainer.innerHTML = `<p style="color:red;">エラー: ${err.message}</p>`;
        } finally {
            window.hideLoading();
        }
    });

  // ← ここでリスナー登録
  window.addEventListener('aggregationRendered', () => {
    console.log('集計描画完了！');
    // たとえばボタンを有効化するとか、別コンポーネントに通知するとか
  });
}

----- C:\Dev\WASABI\static\js\app.js -----
// C:\Dev\WASABI\static\js\app.js

import { initInOut, resetInOutView } from './inout.js';
import { initDatUpload } from './dat.js';
import { initUsageUpload } from './usage.js';
import { initInventoryUpload } from './inventory.js';
import { initAggregation } from './aggregation.js';
import { initMasterEdit, resetMasterEditView } from './master_edit.js';
import { initReprocessButton } from './reprocess.js';
import { initBackupButtons } from './backup.js';
import { initModal } from './inout_modal.js'; 
import { initDeadStock } from './deadstock.js'; 
import { initSettings, onViewShow as onSettingsViewShow } from './settings.js';
import { initMedrec } from './medrec.js'; // ▼▼▼ [修正点] 追加 ▼▼▼
import { initManualInventory } from './manual_inventory.js'; // ▼▼▼ [修正点] 追加 ▼▼▼


// (Global UI Elements and helper functions are unchanged)
window.showLoading = () => document.getElementById('loading-overlay').classList.remove('hidden');
window.hideLoading = () => document.getElementById('loading-overlay').classList.add('hidden');
window.showNotification = (message, type = 'success') => {
    const notificationBox = document.getElementById('notification-box');
    notificationBox.textContent = message;
    notificationBox.className = 'notification-box';
    notificationBox.classList.add(type, 'show');
    setTimeout(() => { notificationBox.classList.remove('show'); }, 3000);
};

document.addEventListener('DOMContentLoaded', () => {
    // (DOM Elements are unchanged)
    const allViews = document.querySelectorAll('main > div[id$="-view"]');
    const inOutBtn = document.getElementById('inOutViewBtn');
    const datBtn = document.getElementById('datBtn');
    const usageBtn = document.getElementById('usageBtn');
    const inventoryBtn = document.getElementById('inventoryBtn');
    const aggregationBtn = document.getElementById('aggregationBtn');
    const masterEditBtn = document.getElementById('masterEditViewBtn');
    const settingsBtn = document.getElementById('settingsBtn'); // ▼▼▼ [修正点] 追加 ▼▼▼
    const datFileInput = document.getElementById('datFileInput');
    const usageFileInput = document.getElementById('usageFileInput');
    const inventoryFileInput = document.getElementById('inventoryFileInput');
    const uploadOutputContainer = document.getElementById('upload-output-container');
    const inventoryOutputContainer = document.getElementById('inventory-output-container');
    const aggregationOutputContainer = document.getElementById('aggregation-output-container');
    const deadStockBtn = document.getElementById('deadStockBtn'); // ▼▼▼ [修正点] 追加 ▼▼▼
    const deadstockOutputContainer = document.getElementById('deadstock-output-container'); // ▼▼▼ [修正点] 追加 ▼▼▼

    // --- Initialize all modules ---
    initInOut();
    initDatUpload();
    initUsageUpload();
    initInventoryUpload();
    initAggregation();
    initMasterEdit();
    initReprocessButton();
    initBackupButtons();
    initModal(); // ▼▼▼ [修正点] モーダルをここで一度だけ初期化 ▼▼▼
    initDeadStock(); // ▼▼▼ [修正点] この一行が抜けていました ▼▼▼
    initSettings(); // ▼▼▼ [修正点] 追加 ▼▼▼
    initMedrec(); // ▼▼▼ [修正点] 追加 ▼▼▼
    initManualInventory(); // ▼▼▼ [修正点] 追加 ▼▼▼

    // (View Switching Logic and Event Listeners are unchanged)
    function showView(viewIdToShow) {
        allViews.forEach(view => {
            view.classList.toggle('hidden', view.id !== viewIdToShow);
        });
    }

    inOutBtn.addEventListener('click', () => { showView('in-out-view'); resetInOutView(); });
    datBtn.addEventListener('click', () => {
        showView('upload-view');
        document.getElementById('upload-view-title').textContent = `DAT File Upload`;
        if (uploadOutputContainer) uploadOutputContainer.innerHTML = '';
        datFileInput.click();
    });
    usageBtn.addEventListener('click', () => {
        showView('upload-view');
        document.getElementById('upload-view-title').textContent = `USAGE File Upload`;
        if (uploadOutputContainer) uploadOutputContainer.innerHTML = '';
        usageFileInput.click();
    });
    inventoryBtn.addEventListener('click', () => {
        showView('inventory-view');
        if (inventoryOutputContainer) inventoryOutputContainer.innerHTML = '';
        inventoryFileInput.click();
    });
        // ▼▼▼ [修正点] 手入力棚卸ボタンのリスナーを追加 ▼▼▼
    manualInventoryBtn.addEventListener('click', () => {
        showView('manual-inventory-view');
        // Dispatch a custom event to trigger loading
        document.getElementById('manual-inventory-view').dispatchEvent(new Event('show'));
    });
    // ▲▲▲ 修正ここまで ▲▲▲
    aggregationBtn.addEventListener('click', () => {
        if (aggregationOutputContainer) aggregationOutputContainer.innerHTML = '';
        showView('aggregation-view');
    });
    deadStockBtn.addEventListener('click', () => {
        if(deadstockOutputContainer) deadstockOutputContainer.innerHTML = '';
        showView('deadstock-view');
    });
    masterEditBtn.addEventListener('click', () => { showView('master-edit-view'); resetMasterEditView(); });
        // ▼▼▼ [修正点] 設定ボタンのリスナーを追加 ▼▼▼
    settingsBtn.addEventListener('click', () => {
        showView('settings-view');
        onSettingsViewShow(); // 画面表示時に設定を読み込む
    });
    // ▲▲▲ 修正ここまで ▲▲▲
    // --- Initial State ---
    showView('in-out-view');
    resetInOutView();
});

----- C:\Dev\WASABI\static\js\backup.js -----
/**
 * ファイルアップロードを処理し、サーバーに送信する共通関数
 * @param {Event} event - ファイル入力のchangeイベント
 * @param {string} url - アップロード先のAPIエンドポイント
 */
async function handleFileUpload(event, url) {
    const fileInput = event.target;
    const file = fileInput.files[0];
    if (!file) return;

    const formData = new FormData();
    formData.append('file', file);
    
    window.showLoading();
    try {
        const res = await fetch(url, {
            method: 'POST',
            body: formData,
        });
        const resData = await res.json();
        if (!res.ok) {
            throw new Error(resData.message || 'インポートに失敗しました。');
        }
        window.showNotification(resData.message, 'success');
    } catch (err) {
        console.error(err);
        window.showNotification(`エラー: ${err.message}`, 'error');
    } finally {
        window.hideLoading();
        fileInput.value = ''; // 次回同じファイルを選択できるようにリセット
    }
}

/**
 * 全てのエクスポート・インポートボタンの機能を初期化する
 */
export function initBackupButtons() {
    // DOM要素を取得
    const exportClientsBtn = document.getElementById('exportClientsBtn');
    const importClientsBtn = document.getElementById('importClientsBtn');
    const importClientsInput = document.getElementById('importClientsInput');
    const exportProductsBtn = document.getElementById('exportProductsBtn');
    const importProductsBtn = document.getElementById('importProductsBtn');
    const importProductsInput = document.getElementById('importProductsInput');

    // 得意先エクスポート
    if (exportClientsBtn) {
        exportClientsBtn.addEventListener('click', () => {
            window.location.href = '/api/clients/export';
        });
    }

    // 得意先インポート
    if (importClientsBtn && importClientsInput) {
        importClientsBtn.addEventListener('click', () => {
            importClientsInput.click();
        });
        importClientsInput.addEventListener('change', (event) => {
            handleFileUpload(event, '/api/clients/import');
        });
    }

    // 製品エクスポート
    if (exportProductsBtn) {
        exportProductsBtn.addEventListener('click', () => {
            window.location.href = '/api/products/export';
        });
    }

    // 製品インポート
    if (importProductsBtn && importProductsInput) {
        importProductsBtn.addEventListener('click', () => {
            importProductsInput.click();
        });
        importProductsInput.addEventListener('change', (event) => {
            handleFileUpload(event, '/api/products/import');
        });
    }
}

----- C:\Dev\WASABI\static\js\common_table.js -----
export const transactionTypeMap = {
    0: "棚卸", 1: "納品", 2: "返品", 3: "処方", 4: "棚卸増",
    5: "棚卸減", 11: "入庫", 12: "出庫", 30: "月末",
};

// teble.htmlのレイアウトを正確に再現する関数
export function createUploadTableHTML(tableId) {
  const colgroup = `
    <colgroup>
      <col class="col-1"><col class="col-2"><col class="col-3"><col class="col-4"><col class="col-5">
      <col class="col-6"><col class="col-7"><col class="col-8"><col class="col-9"><col class="col-10">
      <col class="col-11"><col class="col-12"><col class="col-13"><col class="col-14">
    </colgroup>
  `;
  const header = `
    <thead>
      <tr>
        <th rowspan="2">－</th>
        <th>日付</th><th class="yj-jan-code">YJ</th><th colspan="2">製品名</th>
        <th>個数</th><th>YJ数量</th><th>YJ包装数</th><th>YJ単位</th>
        <th>単価</th><th>税額</th><th>期限</th><th>得意先</th><th>行</th>
      </tr>
      <tr>
        <th>種別</th><th class="yj-jan-code">JAN</th><th>包装</th><th>メーカー</th>
        <th>剤型</th><th>JAN数量</th><th>JAN包装数</th><th>JAN単位</th>
        <th>金額</th><th>税率</th><th>ロット</th><th>伝票番号</th><th>MA</th>
      </tr>
    </thead>
  `;
  return `<table id="${tableId}" class="data-table">${colgroup}${header}<tbody>
    <tr><td colspan="14">ファイルを選択してください。</td></tr>
  </tbody></table>`;
}

// 新レイアウトに合わせて表示用の行を生成する関数
export function renderUploadTableRows(tableId, records) {
  const tbody = document.querySelector(`#${tableId} tbody`);
  if (!records || records.length === 0) {
    tbody.innerHTML = `<tr><td colspan="14">対象データがありません。</td></tr>`;
    return;
  }
  
  let html = "";
  records.forEach(rec => {
    html += `
      <tr>
        <td rowspan="2"></td>
        <td>${rec.transactionDate || ""}</td>
        <td class="yj-jan-code">${rec.yjCode || ""}</td>
        <td class="left" colspan="2">${rec.productName || ""}</td>
        <td class="right">${rec.datQuantity?.toFixed(2) || ""}</td>
        <td class="right">${rec.yjQuantity?.toFixed(2) || ""}</td>
        <td class="right">${rec.yjPackUnitQty || ""}</td>
        <td>${rec.yjUnitName || ""}</td>
        <td class="right">${rec.unitPrice?.toFixed(4) || ""}</td>
        <td class="right">${rec.taxAmount?.toFixed(2) || ""}</td>
        <td>${rec.expiryDate || ""}</td>
        <td class="left">${rec.clientCode || ""}</td>
        <td class="right">${rec.lineNumber || ""}</td>
      </tr>
      <tr>
        <td>${transactionTypeMap[rec.flag] ?? ""}</td>
        <td class="yj-jan-code">${rec.janCode || ""}</td>
        <td class="left">${rec.packageSpec || ""}</td>
        <td class="left">${rec.makerName || ""}</td>
        <td class="left">${rec.usageClassification || ""}</td>
        <td class="right">${rec.janQuantity?.toFixed(2) || ""}</td>
        <td class="right">${rec.janPackUnitQty || ""}</td>
        <td>${rec.janUnitName || ""}</td>
        <td class="right">${rec.subtotal?.toFixed(2) || ""}</td>
        <td class="right">${rec.taxRate != null ? (rec.taxRate * 100).toFixed(0) + "%" : ""}</td>
        <td class="left">${rec.lotNumber || ""}</td>
        <td class="left">${rec.receiptNumber || ""}</td>
        <td class="left">${rec.processFlagMA || ""}</td>
      </tr>
    `;
  });
  tbody.innerHTML = html;
}

// (setupDateDropdown and setupClientDropdown functions are unchanged)
export function setupDateDropdown(inputEl) {
  if (!inputEl) return;
  inputEl.value = new Date().toISOString().slice(0, 10);
}
export async function setupClientDropdown(selectEl) {
  if (!selectEl) return;
  const preservedOptions = Array.from(selectEl.querySelectorAll('option[value=""]'));
  selectEl.innerHTML = '';
  preservedOptions.forEach(opt => selectEl.appendChild(opt));
  try {
    const res = await fetch('/api/clients');
    if (!res.ok) throw new Error('Failed to fetch clients');
    const clients = await res.json();
    if (clients) {
      clients.forEach(c => {
        const opt = document.createElement('option');
        opt.value = c.code;
        opt.textContent = `${c.code}:${c.name}`;
        selectEl.appendChild(opt);
      });
    }
  } catch (err) {
    console.error("得意先リストの取得に失敗:", err);
  }
}

----- C:\Dev\WASABI\static\js\dat.js -----
import { createUploadTableHTML, renderUploadTableRows } from './common_table.js';

export function initDatUpload() {
    const datInput = document.getElementById('datFileInput');
    if (!datInput) return;

    datInput.addEventListener('change', async (e) => {
        const files = e.target.files;
        if (!files.length) return;

        const uploadContainer = document.getElementById('upload-output-container');
        uploadContainer.innerHTML = createUploadTableHTML('upload-output-table');
        const tbody = uploadContainer.querySelector('#upload-output-table tbody');
        tbody.innerHTML = `<tr><td colspan="14" style="text-align:center;">Processing...</td></tr>`;

        window.showLoading();
        try {
            const formData = new FormData();
            for (const file of files) formData.append('file', file);
            
            const res = await fetch('/api/dat/upload', { method: 'POST', body: formData });
            const data = await res.json();
            if (!res.ok) throw new Error(data.message || 'DAT file processing failed.');
            
            renderUploadTableRows('upload-output-table', data.records);
            window.showNotification('DAT files processed successfully.', 'success');
        } catch (err) {
            tbody.innerHTML = `<tr><td colspan="14" style="color:red; text-align:center;">Error: ${err.message}</td></tr>`;
            window.showNotification(err.message, 'error');
        } finally {
            window.hideLoading();
            e.target.value = '';
        }
    });
}

----- C:\Dev\WASABI\static\js\deadstock.js -----
// C:\Dev\WASABI\static\js\deadstock.js

let view, outputContainer, startDateInput, endDateInput, excludeZeroStockCheckbox;

// ▼▼▼ [修正点] HTML生成時に、後で使うYJコードをdata属性に埋め込む ▼▼▼
function createPackageHTML(pkg, yjCode) {
    let rowsHTML = '';
    const janUnit = pkg.yjUnitName || '単位';

    if (pkg.savedRecords && pkg.savedRecords.length > 0) {
        rowsHTML = pkg.savedRecords.map(rec => createRowHTML(rec, janUnit)).join('');
    } else {
        rowsHTML = createRowHTML({ stockQuantityJan: pkg.currentStock }, janUnit);
    }

    return `
        <div class="agg-pkg-header">
            <span>包装: ${pkg.packageForm}|${pkg.janPackInnerQty}|${pkg.yjUnitName}</span>
            <span class="header-info">在庫: ${pkg.currentStock.toFixed(2)} ${janUnit}</span>
        </div>
        <div class="dead-stock-entry-container" data-product-code="${pkg.productCode}" data-yj-code="${yjCode}">
            <table class="dead-stock-entry-table">
                <thead>
                    <tr>
                        <th style="width: 20%;">在庫数量</th>
                        <th style="width: 30%;">使用期限</th>
                        <th style="width: 40%;">ロット番号</th>
                        <th style="width: 10%;">削除</th>
                    </tr>
                </thead>
                <tbody>
                    ${rowsHTML}
                </tbody>
            </table>
            <div class="entry-controls">
                <button class="btn add-ds-row-btn">行追加</button>
                <button class="btn save-ds-btn" style="background-color: #0d6efd; color: white;">この包装の期限・ロットを保存</button>
            </div>
        </div>
    `;
}
// ▲▲▲ 修正ここまで ▲▲▲

function createRowHTML(record = {}, unitName = '単位') {
    const stockQty = record.stockQuantityJan || 0;
    const expiry = record.expiryDate || '';
    const lot = record.lotNumber || '';
    const recordId = record.id || `new-${Date.now()}`;
    return `
        <tr data-record-id="${recordId}">
            <td>
                <div style="display: flex; align-items: center;">
                    <input type="number" class="ds-stock-quantity" value="${stockQty}" step="any" style="flex-grow: 1;">
                    <span class="ds-unit-name" style="margin-left: 5px;">${unitName}</span>
                </div>
            </td>
            <td><input type="text" class="ds-expiry-date" placeholder="YYYYMM" value="${expiry}"></td>
            <td><input type="text" class="ds-lot-number" value="${lot}"></td>
            <td><button class="btn delete-ds-row-btn">－</button></td>
        </tr>
    `;
}

function renderDeadStockList(data) {
    if (!data || data.length === 0) {
        outputContainer.innerHTML = "<p>対象データが見つかりませんでした。</p>";
        return;
    }

    let html = '';
    data.forEach(group => {
        const janUnit = group.packages.length > 0 ? (group.packages[0].yjUnitName || '単位') : '単位';
        html += `
            <div class="agg-yj-header">
                <span>YJ: ${group.yjCode}</span>
                <span class="product-name">${group.productName}</span>
                <span class="header-info">総在庫: ${group.totalStock.toFixed(2)} ${janUnit}</span>
            </div>
        `;
        group.packages.forEach(pkg => {
            // ▼▼▼ [修正点] createPackageHTML に group.yjCode を渡す ▼▼▼
            html += createPackageHTML(pkg, group.yjCode);
            // ▲▲▲ 修正ここまで ▲▲▲
        });
    });
    outputContainer.innerHTML = html;
}


export function initDeadStock() {
    view = document.getElementById('deadstock-view');
    if (!view) return;

    outputContainer = document.getElementById('deadstock-output-container');
    startDateInput = document.getElementById('ds-startDate');
    endDateInput = document.getElementById('ds-endDate');
    excludeZeroStockCheckbox = document.getElementById('ds-exclude-zero-stock');

    const today = new Date();
    const threeMonthsAgo = new Date(today.getFullYear(), today.getMonth() - 3, today.getDate());
    endDateInput.value = today.toISOString().slice(0, 10);
    startDateInput.value = threeMonthsAgo.toISOString().slice(0, 10);
    
    view.addEventListener('click', async (e) => {
        if (e.target.id === 'run-dead-stock-btn') {
            window.showLoading();
            const params = new URLSearchParams({
                startDate: startDateInput.value.replace(/-/g, ''),
                endDate: endDateInput.value.replace(/-/g, ''),
                excludeZeroStock: excludeZeroStockCheckbox.checked,
            });

            try {
                const res = await fetch(`/api/deadstock/list?${params.toString()}`);
                if (!res.ok) {
                    const errText = await res.text();
                    throw new Error(errText || 'Failed to generate dead stock list');
                }
                const data = await res.json();
                renderDeadStockList(data);
            } catch (err) {
                outputContainer.innerHTML = `<p style="color:red;">エラー: ${err.message}</p>`;
            } finally {
                window.hideLoading();
            }
        }

        if (e.target.classList.contains('add-ds-row-btn')) {
            const container = e.target.closest('.dead-stock-entry-container');
            const unitNameSpan = container.querySelector('.ds-unit-name');
            const unitName = unitNameSpan ? unitNameSpan.textContent : '単位';
            const tbody = container.querySelector('tbody');
            tbody.insertAdjacentHTML('beforeend', createRowHTML({}, unitName));
        }

        if (e.target.classList.contains('delete-ds-row-btn')) {
            e.target.closest('tr').remove();
        }

        if (e.target.classList.contains('save-ds-btn')) {
            const container = e.target.closest('.dead-stock-entry-container');
            const productCode = container.dataset.productCode;
            // ▼▼▼ [修正点] YJコードをdata属性から安全に取得する ▼▼▼
            const yjCode = container.dataset.yjCode;
            // ▲▲▲ 修正ここまで ▲▲▲
            const rows = container.querySelectorAll('tbody tr');
            const payload = [];

            const header = container.previousElementSibling;
            const pkgInfo = header.querySelector('span:first-child').textContent.replace('包装: ', '').split('|');
            
            rows.forEach(row => {
                payload.push({
                    productCode: productCode,
                    yjCode: yjCode, // 正しいYJコードをセット
                    packageForm: pkgInfo[0],
                    janPackInnerQty: parseFloat(pkgInfo[1]) || 0,
                    yjUnitName: pkgInfo[2],
                    stockQuantityJan: parseFloat(row.querySelector('.ds-stock-quantity').value) || 0,
                    expiryDate: row.querySelector('.ds-expiry-date').value,
                    lotNumber: row.querySelector('.ds-lot-number').value,
                });
            });

            window.showLoading();
            try {
                const res = await fetch('/api/deadstock/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                const resData = await res.json();
                if (!res.ok) throw new Error(resData.message || '保存に失敗しました。');
                window.showNotification(resData.message, 'success');
            } catch (err) {
                window.showNotification(`エラー: ${err.message}`, 'error');
            } finally {
                window.hideLoading();
            }
        }
    });
}

----- C:\Dev\WASABI\static\js\inout_details_table.js -----
// C:\Dev\WASABI\static\js\inout_details_table.js

import { showModal } from './inout_modal.js';
import { transactionTypeMap, createUploadTableHTML } from './common_table.js';

let tableBody, addRowBtn, tableContainer;

// ▼▼▼ [修正点] 「個数」をINPUTから表示用のセルに変更 ▼▼▼
function createInoutRowsHTML(record = {}) {
    const rowId = record.lineNumber || `new-${Date.now()}`;
    const janQuantity = record.janQuantity ?? 1;
    const datQuantity = record.datQuantity ?? 1; // Default value, will be recalculated
    const nhiPrice = record.nhiPrice || 0;
    const janPackInnerQty = record.janPackInnerQty || 0;
    const yjQuantity = janQuantity * janPackInnerQty;
    const subtotal = yjQuantity * nhiPrice;
    const transactionType = record.flag ? (transactionTypeMap[record.flag] || '') : '';

    const upperRow = `
        <tr data-row-id="${rowId}">
            <td rowspan="2" class="center"><button class="delete-row-btn btn">削除</button></td>
            <td>${record.transactionDate || ''}</td>
            <td class="yj-jan-code display-yj-code">${record.yjCode || ''}</td>
            <td colspan="2" class="product-name-cell left" style="cursor: pointer; text-decoration: underline; color: blue;">${record.productName || 'ここをクリックして製品を検索'}</td>
            <td class="right display-dat-quantity">${datQuantity.toFixed(2)}</td>
            <td class="right display-yj-quantity">${yjQuantity.toFixed(2)}</td>
            <td class="right display-yj-pack-unit-qty">${record.yjPackUnitQty || ''}</td>
            <td class="display-yj-unit-name">${record.yjUnitName || ''}</td>
            <td class="right display-unit-price">${nhiPrice.toFixed(4)}</td>
            <td class="right">${record.taxAmount || ''}</td>
            <td><input type="text" name="expiryDate" value="${record.expiryDate || ''}" placeholder="YYYYMM"></td>
            <td class="left">${record.clientCode || ''}</td>
            <td class="right">${record.lineNumber || ''}</td>
        </tr>`;

    const lowerRow = `
        <tr data-row-id-lower="${rowId}">
            <td>${transactionType}</td>
            <td class="yj-jan-code display-jan-code">${record.productCode || record.janCode || ''}</td>
            <td class="left display-package-spec">${record.formattedPackageSpec || record.packageSpec || ''}</td>
            <td class="left display-maker-name">${record.makerName || ''}</td>
            <td class="left display-usage-classification">${record.usageClassification || ''}</td>
            <td class="right"><input type="number" name="janQuantity" value="${janQuantity}" step="any"></td>
            <td class="right display-jan-pack-unit-qty">${record.janPackUnitQty || ''}</td>
            <td class="display-jan-unit-name">${record.janUnitName || ''}</td>
            <td class="right display-subtotal">${subtotal.toFixed(2)}</td>
            <td class="right">${record.taxRate != null ? (record.taxRate * 100).toFixed(0) + "%" : ""}</td>
            <td class="left"><input type="text" name="lotNumber" value="${record.lotNumber || ''}"></td>
            <td class="left">${record.receiptNumber || ''}</td>
            <td class="left">${record.processFlagMA || ''}</td>
        </tr>`;

    return upperRow + lowerRow;
}

export function populateDetailsTable(records) {
    if (!records || records.length === 0) {
        clearDetailsTable();
        return;
    }
    tableBody.innerHTML = records.map(createInoutRowsHTML).join('');
    
    tableBody.querySelectorAll('tr[data-row-id]').forEach((row, index) => {
        if (records[index]) {
            const masterData = { ...records[index] };
            delete masterData.id;
            delete masterData.runningBalance;
            row.dataset.product = JSON.stringify(masterData);
            recalculateRow(row); // Recalculate to set the initial datQuantity correctly
        }
    });
}

export function clearDetailsTable() {
    if (tableBody) {
        tableBody.innerHTML = `<tr><td colspan="14">ヘッダーで情報を選択後、「明細を追加」ボタンを押してください。</td></tr>`;
    }
}

export function getDetailsData() {
    const records = [];
    const rows = tableBody.querySelectorAll('tr[data-row-id]');
    rows.forEach(row => {
        const productDataString = row.dataset.product;
        if (!productDataString || productDataString === '{}') return;
        const productData = JSON.parse(productDataString);
        const lowerRow = row.nextElementSibling;
        
        const janQuantity = parseFloat(lowerRow.querySelector('input[name="janQuantity"]').value) || 0;
        let datQuantity = 0;
        if(productData.janPackUnitQty > 0) {
            datQuantity = janQuantity / productData.janPackUnitQty;
        }

        const record = {
            productCode: productData.productCode,
            productName: productData.productName,
            datQuantity: datQuantity,
            expiryDate: row.querySelector('input[name="expiryDate"]').value,
            janQuantity: janQuantity,
            lotNumber: lowerRow.querySelector('input[name="lotNumber"]').value,
        };
        records.push(record);
    });
    return records;
}

function recalculateRow(upperRow) {
    const productDataString = upperRow.dataset.product;
    if (!productDataString) return;
    const product = JSON.parse(productDataString);
    const lowerRow = upperRow.nextElementSibling;
    if (!lowerRow) return;
    
    const janQuantity = parseFloat(lowerRow.querySelector('[name="janQuantity"]').value) || 0;
    const nhiPrice = parseFloat(product.nhiPrice) || 0;
    const janPackInnerQty = parseFloat(product.janPackInnerQty) || 0;
    const janPackUnitQty = parseFloat(product.janPackUnitQty) || 0;

    let datQuantity = 0;
    if(janPackUnitQty > 0) {
        datQuantity = janQuantity / janPackUnitQty;
    }
    const yjQuantity = janQuantity * janPackInnerQty;
    const subtotal = yjQuantity * nhiPrice;

    upperRow.querySelector('.display-dat-quantity').textContent = datQuantity.toFixed(2);
    upperRow.querySelector('.display-yj-quantity').textContent = yjQuantity.toFixed(2);
    lowerRow.querySelector('.display-subtotal').textContent = subtotal.toFixed(2);
}
// ▲▲▲ 修正ここまで ▲▲▲

export function initDetailsTable() {
    tableContainer = document.getElementById('inout-details-container');
    addRowBtn = document.getElementById('addRowBtn');
    if (!tableContainer || !addRowBtn) return;
    
    tableContainer.innerHTML = createUploadTableHTML('inout-details-table');
    tableBody = document.querySelector('#inout-details-table tbody');
    
    addRowBtn.addEventListener('click', () => {
        if (tableBody.querySelector('td[colspan="14"]')) {
            tableBody.innerHTML = '';
        }
        tableBody.insertAdjacentHTML('beforeend', createInoutRowsHTML());
    });

    tableBody.addEventListener('click', (e) => {
        if (e.target.classList.contains('delete-row-btn')) {
            const upperRow = e.target.closest('tr');
            const lowerRow = upperRow.nextElementSibling;
            if(lowerRow) lowerRow.remove();
            upperRow.remove();
            if (tableBody.children.length === 0) {
                 clearDetailsTable();
            }
        }
        // ▼▼▼ [修正点] モーダル呼び出し時に、実行したい処理（コールバック）を直接渡す ▼▼▼
        if (e.target.classList.contains('product-name-cell')) {
            const activeRow = e.target.closest('tr');
            showModal(activeRow, (selectedProduct, targetRow) => {
                targetRow.dataset.product = JSON.stringify(selectedProduct);
                const lowerRow = targetRow.nextElementSibling;
                
                targetRow.querySelector('.display-yj-code').textContent = selectedProduct.yjCode;
                targetRow.querySelector('.product-name-cell').textContent = selectedProduct.productName;
                targetRow.querySelector('.display-yj-pack-unit-qty').textContent = selectedProduct.yjPackUnitQty || '';
                targetRow.querySelector('.display-yj-unit-name').textContent = selectedProduct.yjUnitName || '';
                targetRow.querySelector('.display-unit-price').textContent = (selectedProduct.nhiPrice || 0).toFixed(4);
                
                lowerRow.querySelector('.display-jan-code').textContent = selectedProduct.productCode;
                lowerRow.querySelector('.display-package-spec').textContent = selectedProduct.formattedPackageSpec || '';
                lowerRow.querySelector('.display-maker-name').textContent = selectedProduct.makerName;
                lowerRow.querySelector('.display-usage-classification').textContent = selectedProduct.usageClassification || '';
                lowerRow.querySelector('.display-jan-pack-unit-qty').textContent = selectedProduct.janPackUnitQty || '';
                lowerRow.querySelector('.display-jan-unit-name').textContent = selectedProduct.janUnitName || '';
                
                const quantityInput = lowerRow.querySelector('input[name="janQuantity"]');
                quantityInput.focus();
                quantityInput.select();
                recalculateRow(targetRow);
            });
        }
        // ▲▲▲ 修正ここまで ▲▲▲
    });

    tableBody.addEventListener('input', (e) => {
        const upperRow = e.target.closest('tr[data-row-id]') || e.target.closest('tr[data-row-id-lower]')?.previousElementSibling;
        if(upperRow) {
            recalculateRow(upperRow);
        }
    });
}

----- C:\Dev\WASABI\static\js\inout_header.js -----
import { setupDateDropdown, setupClientDropdown } from './common_table.js';

const NEW_ENTRY_VALUE = '--new--';
let clientSelect, receiptSelect, saveBtn, deleteBtn, headerDateInput, headerTypeSelect;
let newClientName = null;
let currentLoadedReceipt = null;

async function initializeClientDropdown() {
    clientSelect.innerHTML = `<option value="">選択してください</option>`;
    await setupClientDropdown(clientSelect);
    
    const newOption = document.createElement('option');
    newOption.value = NEW_ENTRY_VALUE;
    newOption.textContent = '--- 新規作成 ---';
    clientSelect.appendChild(newOption);
}

export function resetHeader() {
    if (!clientSelect || !headerDateInput) return;
    setupDateDropdown(headerDateInput);
    initializeClientDropdown(); // Dropdown population is now centralized here
    
    receiptSelect.innerHTML = `
        <option value="">日付を選択してください</option>
        <option value="${NEW_ENTRY_VALUE}">--- 新規作成 ---</option>
    `;
    headerTypeSelect.value = "入庫";
    newClientName = null;
    currentLoadedReceipt = null;
    deleteBtn.disabled = true;
    headerDateInput.dispatchEvent(new Event('change'));
}

export async function initHeader(getDetailsData, clearDetailsTable, populateDetailsTable) {
    clientSelect = document.getElementById('in-out-client');
    receiptSelect = document.getElementById('in-out-receipt');
    saveBtn = document.getElementById('saveBtn');
    deleteBtn = document.getElementById('deleteBtn');
    headerDateInput = document.getElementById('in-out-date');
    headerTypeSelect = document.getElementById('in-out-type');

    if (!clientSelect || !receiptSelect || !saveBtn || !deleteBtn) return;
    
    // [修正点] initHeaderからはdropdownの初期化呼び出しを削除し、イベントリスナーの設定のみに限定
    
    // --- ONE-TIME EVENT LISTENER SETUP ---
    headerDateInput.addEventListener('change', async () => {
        const date = headerDateInput.value.replace(/-/g, '');
        if (!date) return;
        try {
            const res = await fetch(`/api/receipts?date=${date}`);
            if (!res.ok) throw new Error('伝票の取得に失敗');
            const receiptNumbers = await res.json();
            
            receiptSelect.innerHTML = `
                <option value="">選択してください</option>
                <option value="${NEW_ENTRY_VALUE}">--- 新規作成 ---</option>
            `;
            if (receiptNumbers && receiptNumbers.length > 0) {
                receiptNumbers.forEach(num => {
                    const opt = document.createElement('option');
                    opt.value = num;
                    opt.textContent = num;
                    receiptSelect.appendChild(opt);
                });
            }
        } catch (err) { console.error(err); }
    });

    clientSelect.addEventListener('change', () => {
        const selectedValue = clientSelect.value;
        if (selectedValue === NEW_ENTRY_VALUE) {
            const name = prompt('新しい得意先名を入力してください:');
            if (name && name.trim()) {
                newClientName = name.trim();
                const opt = document.createElement('option');
                opt.value = `new:${newClientName}`;
                opt.textContent = `[新規] ${newClientName}`;
                opt.selected = true;
                clientSelect.appendChild(opt);
            } else {
                clientSelect.value = '';
            }
        } else if (!selectedValue.startsWith('new:')) {
            newClientName = null;
        }
    });

    receiptSelect.addEventListener('change', async () => {
        const selectedValue = receiptSelect.value;
        deleteBtn.disabled = (selectedValue === NEW_ENTRY_VALUE || selectedValue === "");

        if (selectedValue === NEW_ENTRY_VALUE || selectedValue === "") {
            clearDetailsTable();
            currentLoadedReceipt = null;
        } else {
            window.showLoading();
            try {
                const res = await fetch(`/api/transaction/${selectedValue}`);
                if (!res.ok) throw new Error('明細の読込に失敗');
                const records = await res.json();
                if (records && records.length > 0) {
                    currentLoadedReceipt = selectedValue;
                    clientSelect.value = records[0].clientCode;
                    headerTypeSelect.value = records[0].flag === 11 ? "入庫" : "出庫";
                    newClientName = null;
                }
                populateDetailsTable(records);
            } catch (err) {
                console.error(err);
                window.showNotification(err.message, 'error');
            } finally {
                window.hideLoading();
            }
        }
    });

    saveBtn.addEventListener('click', async () => {
        let clientCode = clientSelect.value;
        let clientNameToSave = '';
        let isNewClient = false;
        if (newClientName && clientCode.startsWith('new:')) {
            clientNameToSave = newClientName;
            isNewClient = true;
            clientCode = '';
        } else {
            if (!clientCode || clientCode === NEW_ENTRY_VALUE) {
                window.showNotification('得意先を選択または新規作成してください。', 'error');
                return;
            }
        }
        const records = getDetailsData();
        if (records.length === 0) {
            window.showNotification('保存する明細データがありません。', 'error');
            return;
        }
        const payload = {
            isNewClient, clientCode, clientName: clientNameToSave,
            transactionDate: headerDateInput.value.replace(/-/g, ''),
            transactionType: headerTypeSelect.value,
            records: records,
            originalReceiptNumber: currentLoadedReceipt
        };
        window.showLoading();
        try {
            const res = await fetch('/api/inout/save', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
            });
            const resData = await res.json();
            if (!res.ok) {
                throw new Error(resData.message || `保存に失敗しました (HTTP ${res.status})`);
            }
            window.showNotification(`データを保存しました。\n伝票番号: ${resData.receiptNumber}`, 'success');
            resetHeader();
            clearDetailsTable();
        } catch (err) {
            console.error(err);
            window.showNotification(err.message, 'error');
        } finally {
            window.hideLoading();
        }
    });

    deleteBtn.addEventListener('click', async () => {
        const receiptNumber = receiptSelect.value;
        if (!receiptNumber || receiptNumber === NEW_ENTRY_VALUE) {
            window.showNotification("削除対象の伝票が選択されていません。", 'error');
            return;
        }
        if (!confirm(`伝票番号 [${receiptNumber}] を完全に削除します。よろしいですか？`)) {
            return;
        }
        window.showLoading();
        try {
            const res = await fetch(`/api/transaction/delete/${receiptNumber}`, { method: 'DELETE' });
            const errData = await res.json().catch(() => null);
            if (!res.ok) {
                throw new Error(errData?.message || '削除に失敗しました。');
            }
            window.showNotification(`伝票 [${receiptNumber}] を削除しました。`, 'success');
            resetHeader();
            clearDetailsTable();
        } catch(err) {
            console.error(err);
            window.showNotification(err.message, 'error');
        } finally {
            window.hideLoading();
        }
    });
}

----- C:\Dev\WASABI\static\js\inout_modal.js -----
// C:\Dev\WASABI\static\js\inout_modal.js

let activeCallback = null;
let activeRowElement = null;

const modal = document.getElementById('search-modal');
const closeModalBtn = document.getElementById('closeModalBtn');
const searchInput = document.getElementById('product-search-input');
const searchBtn = document.getElementById('product-search-btn');
const searchResultsBody = document.querySelector('#search-results-table tbody');

function handleResultClick(event) {
  if (event.target && event.target.classList.contains('select-product-btn')) {
    const product = JSON.parse(event.target.dataset.product);
    if (typeof activeCallback === 'function') {
      activeCallback(product, activeRowElement);
    }
    modal.classList.add('hidden');
  }
}

async function performSearch() {
  const query = searchInput.value.trim();
  if (query.length < 2) {
    alert('2文字以上入力してください。');
    return;
  }
  searchResultsBody.innerHTML = '<tr><td colspan="6" class="center">検索中...</td></tr>';
  try {
    const res = await fetch(`/api/products/search?q=${encodeURIComponent(query)}`);
    if (!res.ok) {
        throw new Error(`サーバーエラー: ${res.status}`);
    }
    const products = await res.json();
    renderSearchResults(products);
  } catch (err) {
    searchResultsBody.innerHTML = `<tr><td colspan="6" class="center" style="color:red;">${err.message}</td></tr>`;
  }
}

function renderSearchResults(products) {
  if (!products || products.length === 0) {
    searchResultsBody.innerHTML = '<tr><td colspan="6" class="center">該当する製品が見つかりません。</td></tr>';
    return;
  }

  let html = '';
  products.forEach(p => {
    const productData = JSON.stringify(p);
    html += `
      <tr>
        <td class="left">${p.productName || ''}</td>
        <td class="left">${p.makerName || ''}</td>
        <td class="left">${p.formattedPackageSpec}</td>
        <td>${p.yjCode || ''}</td>
        <td>${p.productCode || ''}</td>
        <td><button class="select-product-btn" data-product='${productData.replace(/'/g, "&apos;")}'>選択</button></td>
      </tr>
    `;
  });
  searchResultsBody.innerHTML = html;
}

// ▼▼▼ [修正点] 起動時に一度だけイベントリスナーを設定するinit関数に変更 ▼▼▼
export function initModal() {
  if (!modal || !closeModalBtn || !searchInput || !searchBtn || !searchResultsBody) {
    console.error("薬品検索モーダルの必須要素が見つかりません。");
    return;
  }
  closeModalBtn.addEventListener('click', () => modal.classList.add('hidden'));
  searchBtn.addEventListener('click', performSearch);
  searchInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      performSearch();
    }
  });
  searchResultsBody.addEventListener('click', handleResultClick);
}
// ▲▲▲ 修正ここまで ▲▲▲

// ▼▼▼ [修正点] showModalが実行するべきコールバック関数を引数で受け取るように変更 ▼▼▼
export function showModal(rowElement, callback) {
  if (modal) {
    activeRowElement = rowElement;
    activeCallback = callback; // 実行する処理をセット
    modal.classList.remove('hidden');
    searchInput.value = '';
    searchInput.focus();
    searchResultsBody.innerHTML = '<tr><td colspan="6" class="center">製品名を入力して検索してください。</td></tr>';
  }
}
// ▲▲▲ 修正ここまで ▲▲▲

----- C:\Dev\WASABI\static\js\inout.js -----
import { initHeader, resetHeader } from './inout_header.js';
import { initDetailsTable, getDetailsData, clearDetailsTable, populateDetailsTable } from './inout_details_table.js';

export async function initInOut() {
  initDetailsTable();
  await initHeader(getDetailsData, clearDetailsTable, populateDetailsTable);
}

export function resetInOutView() {
    clearDetailsTable();
    resetHeader();
}

----- C:\Dev\WASABI\static\js\inventory.js -----
import { createUploadTableHTML, renderUploadTableRows } from './common_table.js';

// DOM要素をキャッシュ
const fileInput = document.getElementById('inventoryFileInput');
const outputContainer = document.getElementById('inventory-output-container');

async function handleInventoryUpload(event) {
    const files = event.target.files;
    if (!files.length) return;

    // テーブルの準備と処理中メッセージの表示
    outputContainer.innerHTML = createUploadTableHTML('inventory-output-table');
    const tbody = outputContainer.querySelector('tbody');
    tbody.innerHTML = `<tr><td colspan="14" class="center">Processing...</td></tr>`;
    
    window.showLoading();
    try {
        const formData = new FormData();
        for (const file of files) {
            formData.append('file', file);
        }

        const response = await fetch('/api/inventory/upload', {
            method: 'POST',
            body: formData,
        });

        const data = await response.json();
        if (!response.ok) {
            throw new Error(data.message || 'Inventory file processing failed.');
        }

        // 共通のテーブル描画関数を使って結果を表示
        renderUploadTableRows('inventory-output-table', data.details);
        window.showNotification(data.message || 'Inventory file processed successfully.', 'success');
    } catch (err) {
        tbody.innerHTML = `<tr><td colspan="14" class="center" style="color:red;">Error: ${err.message}</td></tr>`;
        window.showNotification(err.message, 'error');
    } finally {
        window.hideLoading();
        event.target.value = ''; // ファイル入力をリセット
    }
}

export function initInventoryUpload() {
    if (!fileInput) return;
    fileInput.addEventListener('change', handleInventoryUpload);
}

----- C:\Dev\WASABI\static\js\manual_inventory.js -----
// C:\Dev\WASABI\static\js\manual_inventory.js

export function initManualInventory() {
    const view = document.getElementById('manual-inventory-view');
    if (!view) return;

    const dateInput = document.getElementById('manual-inv-date');
    const saveBtn = document.getElementById('save-manual-inv-btn');
    const container = document.getElementById('manual-inventory-container');
    let allProducts = [];

    dateInput.value = new Date().toISOString().slice(0, 10);

    async function loadProducts() {
        container.innerHTML = '<p>製品マスターを読み込んでいます...</p>';
        try {
            const res = await fetch('/api/inventory/list');
            if (!res.ok) throw new Error('製品リストの取得に失敗しました。');
            allProducts = await res.json();
            if(!allProducts) allProducts = [];
            renderProducts();
        } catch (err) {
            container.innerHTML = `<p style="color:red;">${err.message}</p>`;
        }
    }

    function renderProducts() {
        if (allProducts.length === 0) {
            container.innerHTML = '<p>表示する製品マスターがありません。</p>';
            return;
        }

        const groups = allProducts.reduce((acc, p) => {
            const key = p.yjCode || 'YJコードなし';
            if (!acc[key]) {
                acc[key] = {
                    productName: p.productName,
                    yjCode: p.yjCode,
                    packages: []
                };
            }
            acc[key].packages.push(p);
            return acc;
        }, {});

        Object.values(groups).forEach(group => {
            group.packages = group.packages.reduce((acc, p) => {
                 const key = `${p.packageForm}|${p.janPackInnerQty}|${p.yjUnitName}`;
                 if (!acc[key]) {
                     acc[key] = {
                         packageKey: key,
                         masters: []
                     };
                 }
                 acc[key].masters.push(p);
                 return acc;
            }, {});
        });

        let html = '';
        for (const group of Object.values(groups).sort((a,b) => a.productName.localeCompare(b.productName, 'ja'))) {
            html += `<div class="agg-yj-header"><span>YJ: ${group.yjCode}</span><span class="product-name">${group.productName}</span></div>`;

            for (const pkg of Object.values(group.packages)) {
                const firstMaster = pkg.masters[0];
                const productCodes = pkg.masters.map(m => m.productCode).join(',');
                html += `
                    <div class="agg-pkg-header" style="display:flex; align-items:center; gap: 10px;">
                        <span>包装: ${pkg.packageKey}</span>
                        <div style="margin-left:auto;">
                            <label for="inv-qty-${firstMaster.productCode}">在庫数:</label>
                            <input type="number" step="any" class="manual-inv-qty" data-product-codes="${productCodes}" id="inv-qty-${firstMaster.productCode}" style="width: 100px;">
                            <span>${firstMaster.yjUnitName || ''}</span>
                        </div>
                    </div>
                `;
            }
        }
        container.innerHTML = html;
    }
    
    view.addEventListener('show', loadProducts);

    saveBtn.addEventListener('click', async () => {
        const date = dateInput.value.replace(/-/g, '');
        if (!date) {
            window.showNotification('棚卸日を指定してください。', 'error');
            return;
        }
        if (!confirm(`${dateInput.value} の棚卸データとして保存します。よろしいですか？`)) {
            return;
        }

        const records = [];
        container.querySelectorAll('.manual-inv-qty').forEach(input => {
            // ▼▼▼ [修正点] 空文字は無視し、0はデータとして送信する ▼▼▼
            if (input.value !== '') { 
                const quantity = parseFloat(input.value);
                if (!isNaN(quantity)) {
                    const productCode = input.dataset.productCodes.split(',')[0];
                    records.push({
                        productCode: productCode,
                        yjQuantity: quantity
                    });
                }
            }
            // ▲▲▲ 修正ここまで ▲▲▲
        });

        window.showLoading();
        try {
            const res = await fetch('/api/inventory/save_manual', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ date, records }),
            });
            const resData = await res.json();
            if (!res.ok) throw new Error(resData.message || '保存に失敗しました。');
            window.showNotification(resData.message, 'success');
            loadProducts();
        } catch (err) {
            window.showNotification(err.message, 'error');
        } finally {
            window.hideLoading();
        }
    });
}

----- C:\Dev\WASABI\static\js\master_edit.js -----
// C:\Dev\WASABI\static\js\master_edit.js

import { showModal } from './inout_modal.js';

let view, tableContainer, refreshBtn, addRowBtn;
let unitMap = {};

async function fetchUnitMap(){if(Object.keys(unitMap).length>0)return;try{const res=await fetch('/api/units/map');if(!res.ok)throw new Error('単位マスタの取得に失敗');unitMap=await res.json();}catch(err){console.error(err);window.showNotification(err.message,'error');}}
function formatPackageSpecForRow(tbody){if(!tbody)return;const getVal=(name)=>tbody.querySelector(`[name="${name}"]`)?.value||'';const packageForm=getVal('packageForm');const yjPackUnitQty=getVal('yjPackUnitQty');const yjUnitName=getVal('yjUnitName');const janPackInnerQty=getVal('janPackInnerQty');const janPackUnitQty=getVal('janPackUnitQty');const janUnitCode=getVal('janUnitCode');let formattedSpec=`${packageForm} ${yjPackUnitQty}${yjUnitName}`;if(parseFloat(janPackInnerQty)>0&&parseFloat(janPackUnitQty)>0){let janUnitName=(janUnitCode==='0'||janUnitCode==='')?'':(unitMap[janUnitCode]||'');formattedSpec+=` (${janPackInnerQty}${yjUnitName}×${janPackUnitQty}${janUnitName})`;}
const targetCell=tbody.querySelector('.formatted-spec-cell');if(targetCell)targetCell.textContent=formattedSpec;}
function createMasterRowHTML(master={}){const isNew=!master.productCode;const rowId=master.productCode||`new-${Date.now()}`;const topRowFields=[{key:'productCode',ph:'製品コード(JAN)',readonly:!isNew},{key:'yjCode',ph:'YJコード'},{key:'productName',ph:'製品名'},{key:'kanaName',ph:'カナ名'},{key:'makerName',ph:'メーカー名'},{key:'usageClassification',ph:'剤型(JC013)'},{key:'nhiPrice',ph:'薬価',type:'number',step:'0.0001',value:master.nhiPrice||0},];const flags=[{key:'flagPoison',ph:'毒',opts:[0,1]},{key:'flagDeleterious',ph:'劇',opts:[0,1]},{key:'flagNarcotic',ph:'麻',opts:[0,1]},{key:'flagPsychotropic',ph:'向',opts:[0,1,2,3]},{key:'flagStimulant',ph:'覚',opts:[0,1]},{key:'flagStimulantRaw',ph:'覚原',opts:[0,1]},];const bottomRowFields=[{key:'packageForm',ph:'包装(JC037)'},{key:'yjUnitName',ph:'YJ単位'},{key:'yjPackUnitQty',ph:'YJ包装数量',type:'number',value:master.yjPackUnitQty||0},{key:'janPackInnerQty',ph:'内包装数量',type:'number',value:master.janPackInnerQty||0},{key:'janUnitCode',ph:'JAN単位',type:'select',value:master.janUnitCode||0},{key:'janPackUnitQty',ph:'JAN包装数量',type:'number',value:master.janPackUnitQty||0},];let topRowCellsHTML=topRowFields.map(f=>`<td><input type="${f.type||'text'}" name="${f.key}" value="${f.value||master[f.key]||''}" placeholder="${f.ph}" ${f.readonly?'readonly':''} ${f.step?`step="${f.step}"`:''}></td>`).join('');topRowCellsHTML+=flags.map(f=>{const options=f.opts.map(o=>`<option value="${o}" ${o==(master[f.key]||0)?'selected':''}>${o}</option>`).join('');return`<td><select name="${f.key}">${options}</select></td>`;}).join('');topRowCellsHTML+=`<td><button class="save-master-btn btn">保存</button></td>`;let bottomRowCellsHTML=bottomRowFields.map(f=>{if(f.type==='select'){let options=`<option value="0">YJ単位と同じ</option>`;for(const[code,name]of Object.entries(unitMap)){if(code!=='0')options+=`<option value="${code}" ${code==f.value?'selected':''}>${name}</option>`;}
return`<td><select name="${f.key}">${options}</select></td>`;}
return`<td><input type="${f.type||'text'}" name="${f.key}" value="${f.value||master[f.key]||''}" placeholder="${f.ph}"></td>`;}).join('');bottomRowCellsHTML+=`<td class="formatted-spec-cell" colspan="7"></td><td><button class="quote-jcshms-btn btn">引用</button></td>`;return`<tbody data-record-id="${rowId}"><tr class="data-row-top">${topRowCellsHTML}</tr><tr class="data-row-bottom">${bottomRowCellsHTML}</tr></tbody>`;}
async function loadAndRenderMasters(){tableContainer.innerHTML=`<table><tbody><tr><td>読み込み中...</td></tr></tbody></table>`;try{const res=await fetch('/api/masters/editable');if(!res.ok)throw new Error('マスターの読み込みに失敗しました。');const masters=await res.json();const tableHeader=`<thead>
            <tr><th>製品コード(JAN)</th><th>YJコード</th><th>製品名</th><th>カナ名</th><th>メーカー名</th><th>剤型</th><th>薬価</th><th>毒</th><th>劇</th><th>麻</th><th>向</th><th>覚</th><th>覚原</th><th>操作</th></tr>
            <tr><th>包装</th><th>YJ単位</th><th>YJ包装数量</th><th>内包装数量</th><th>JAN単位</th><th>JAN包装数量</th><th colspan="7">組み立て包装</th><th>操作</th></tr>
        </thead>`;const tableContent=masters.map(createMasterRowHTML).join('');tableContainer.innerHTML=`<table class="data-table">${tableHeader}${tableContent}</table>`;tableContainer.querySelectorAll('tbody[data-record-id]').forEach(formatPackageSpecForRow);}catch(err){tableContainer.innerHTML=`<p style="color:red;">${err.message}</p>`;}}

function populateFormWithJcshms(selectedProduct, tbody) {
    if (!tbody) return;
    const setVal = (name, value) => {
        const el = tbody.querySelector(`[name="${name}"]`);
        if (el) el.value = value !== undefined ? value : '';
    };

    const productCodeInput = tbody.querySelector('[name="productCode"]');
    if (productCodeInput && !productCodeInput.readOnly) {
        productCodeInput.value = selectedProduct.productCode || '';
    }
    
    setVal('yjCode', selectedProduct.yjCode); setVal('productName', selectedProduct.productName);
    setVal('kanaName', selectedProduct.kanaName); setVal('makerName', selectedProduct.makerName);
    setVal('usageClassification', selectedProduct.usageClassification); setVal('packageForm', selectedProduct.packageForm);
    setVal('nhiPrice', selectedProduct.nhiPrice); setVal('flagPoison', selectedProduct.flagPoison);
    setVal('flagDeleterious', selectedProduct.flagDeleterious); setVal('flagNarcotic', selectedProduct.flagNarcotic);
    setVal('flagPsychotropic', selectedProduct.flagPsychotropic); setVal('flagStimulant', selectedProduct.flagStimulant);
    setVal('flagStimulantRaw', selectedProduct.flagStimulantRaw); setVal('yjUnitName', selectedProduct.yjUnitName);
    setVal('yjPackUnitQty', selectedProduct.yjPackUnitQty); setVal('janPackInnerQty', selectedProduct.janPackInnerQty);
    setVal('janUnitCode', selectedProduct.janUnitCode); setVal('janPackUnitQty', selectedProduct.janPackUnitQty);
    
    formatPackageSpecForRow(tbody);
}

export async function initMasterEdit() {
    view = document.getElementById('master-edit-view');
    if (!view) return;

    tableContainer = document.getElementById('master-edit-container');
    refreshBtn = document.getElementById('refreshMastersBtn');
    addRowBtn = document.getElementById('addMasterRowBtn');

    await fetchUnitMap();
    // ▼▼▼ [修正点] initModalの呼び出しを削除 ▼▼▼
    // initModal(populateFormWithJcshms);
    // ▲▲▲ 修正ここまで ▲▲▲

    refreshBtn.addEventListener('click', loadAndRenderMasters);
    addRowBtn.addEventListener('click', () => {
        const table = tableContainer.querySelector('table');
        if (table) table.insertAdjacentHTML('beforeend', createMasterRowHTML());
    });

    tableContainer.addEventListener('input', (e) => {
        const tbody = e.target.closest('tbody[data-record-id]');
        if (tbody) formatPackageSpecForRow(tbody);
    });

    tableContainer.addEventListener('click', async (e) => {
        const target = e.target;
        const tbody = target.closest('tbody[data-record-id]');
        if (!tbody) return;

        if (target.classList.contains('save-master-btn')) {
            const data = {};
            tbody.querySelectorAll('input, select').forEach(el => {
                const name = el.name;
                const value = el.value;
                if (el.tagName === 'SELECT' || el.type === 'number') {
                    data[name] = parseFloat(value) || 0;
                } else {
                    data[name] = value;
                }
            });
            
            data.packageSpec = data.packageForm;
            data.origin = "MANUAL"; data.purchasePrice = 0; data.supplierWholesale = '';

            if (!data.productCode) {
                window.showNotification('製品コードは必須です。', 'error');
                return;
            }
            
            window.showLoading();
            try {
                const res = await fetch('/api/master/update', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data),
                });
                const resData = await res.json();
                if (!res.ok) throw new Error(resData.message || '保存に失敗しました。');
                
                window.showNotification(resData.message, 'success');
                loadAndRenderMasters();
            } catch (err) {
                window.showNotification(err.message, 'error');
            } finally {
                window.hideLoading();
            }
        }
        // ▼▼▼ [修正点] モーダル呼び出し時に、実行したい処理（コールバック）を直接渡す ▼▼▼
        if (target.classList.contains('quote-jcshms-btn')) {
            showModal(tbody, populateFormWithJcshms);
        }
        // ▲▲▲ 修正ここまで ▲▲▲
    });
}

export function resetMasterEditView() {
    if (tableContainer) {
        loadAndRenderMasters();
    }
}

----- C:\Dev\WASABI\static\js\medrec.js -----
// C:\Dev\WASABI\static\js\medrec.js

export function initMedrec() {
    const downloadBtn = document.getElementById('medrecDownloadBtn');
    if (!downloadBtn) return;

    downloadBtn.addEventListener('click', async () => {
        if (!confirm('e-mednet.jpにログインし、納品データをダウンロードします。よろしいですか？')) {
            return;
        }

        window.showLoading();
        try {
            const res = await fetch('/api/medrec/download', {
                method: 'POST',
            });
            
            const resData = await res.json();
            if (!res.ok) {
                // res.json() failed or server returned an error message
                throw new Error(resData.message || `ダウンロードに失敗しました (HTTP ${res.status})`);
            }
            window.showNotification(resData.message, 'success');
        } catch (err) {
            // This catches network errors or errors thrown from the !res.ok check
            console.error('Download failed:', err);
            // Attempt to get a more specific error message if the response was text
            const errorMessage = err.message || 'サーバーとの通信に失敗しました。設定画面でID/パスワードが正しいか確認してください。';
            window.showNotification(errorMessage, 'error');
        } finally {
            window.hideLoading();
        }
    });
}

----- C:\Dev\WASABI\static\js\reprocess.js -----
export function initReprocessButton() {
    const reprocessBtn = document.getElementById('reprocessBtn');
    if (!reprocessBtn) return;

    reprocessBtn.addEventListener('click', async () => {
        if (!confirm('仮登録状態の取引データを、最新のマスター情報で更新します。よろしいですか？')) {
            return;
        }

        window.showLoading();
        try {
            const res = await fetch('/api/transactions/reprocess', {
                method: 'POST',
            });
            const data = await res.json();
            if (!res.ok) {
                throw new Error(data.message || '処理に失敗しました。');
            }
            window.showNotification(data.message, 'success');
        } catch (err) {
            console.error(err);
            window.showNotification(`エラー: ${err.message}`, 'error');
        } finally {
            window.hideLoading();
        }
    });
}

----- C:\Dev\WASABI\static\js\settings.js -----
let view, userIDInput, passwordInput, saveBtn;

async function loadSettings() {
    try {
        const res = await fetch('/api/settings/get');
        if (!res.ok) throw new Error('設定の読み込みに失敗しました。');
        const settings = await res.json();
        userIDInput.value = settings.emednetUserId || '';
        passwordInput.value = settings.emednetPassword || '';
    } catch (err) {
        window.showNotification(err.message, 'error');
    }
}

async function saveSettings() {
    const settings = {
        emednetUserId: userIDInput.value,
        emednetPassword: passwordInput.value,
    };

    window.showLoading();
    try {
        const res = await fetch('/api/settings/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(settings),
        });
        const resData = await res.json();
        if (!res.ok) throw new Error(resData.message || '設定の保存に失敗しました。');
        window.showNotification(resData.message, 'success');
    } catch (err) {
        window.showNotification(err.message, 'error');
    } finally {
        window.hideLoading();
    }
}

export function initSettings() {
    view = document.getElementById('settings-view');
    if (!view) return;

    userIDInput = document.getElementById('emednetUserID');
    passwordInput = document.getElementById('emednetPassword');
    saveBtn = document.getElementById('saveSettingsBtn');

    saveBtn.addEventListener('click', saveSettings);
}

// 画面が表示されるたびに最新の設定を読み込むための関数
export function onViewShow() {
    loadSettings();
}

----- C:\Dev\WASABI\static\js\upload.js -----
import { createUploadTableHTML, renderUploadTableRows } from './common_table.js';

let currentUploadType = '';
const fileInputs = {
    dat: document.getElementById('datFileInput'),
    usage: document.getElementById('usageFileInput'),
};

async function handleFileUpload(type, files) {
    if (!files.length) return;
    const uploadContainer = document.getElementById('upload-output-container');
    uploadContainer.innerHTML = createUploadTableHTML('upload-output-table');
    const tbody = uploadContainer.querySelector('tbody');
    tbody.innerHTML = `<tr><td colspan="14" class="center">Processing...</td></tr>`;
    window.showLoading();
    try {
        const formData = new FormData();
        for (const file of files) formData.append('file', file);
        const res = await fetch(`/api/${type}/upload`, { method: 'POST', body: formData });
        const data = await res.json();
        if (!res.ok) throw new Error(data.message || `${type.toUpperCase()} file processing failed.`);
        renderUploadTableRows('upload-output-table', data.records || data.details);
        window.showNotification(`${type.toUpperCase()} file(s) processed.`, 'success');
    } catch (err) {
        tbody.innerHTML = `<tr><td colspan="14" class="center" style="color:red;">Error: ${err.message}</td></tr>`;
        window.showNotification(err.message, 'error');
    } finally {
        window.hideLoading();
        if (fileInputs[type]) fileInputs[type].value = '';
    }
}

export function initUploadView() {
    fileInputs.dat.addEventListener('change', (e) => handleFileUpload('dat', e.target.files));
    fileInputs.usage.addEventListener('change', (e) => handleFileUpload('usage', e.target.files));
    document.addEventListener('showUploadView', (e) => {
        currentUploadType = e.detail.type;
        const title = document.getElementById('upload-view-title');
        const container = document.getElementById('upload-output-container');
        if (title) title.textContent = `${currentUploadType.toUpperCase()} File Upload`;
        if (container) container.innerHTML = `<p>Click the ${currentUploadType.toUpperCase()} button again to select files.</p>`;
        if (fileInputs[currentUploadType]) fileInputs[currentUploadType].click();
    });
}
export function resetUploadView() {
    const title = document.getElementById('upload-view-title');
    const container = document.getElementById('upload-output-container');
    if (title) title.textContent = 'File Upload';
    if (container) container.innerHTML = '';
}

----- C:\Dev\WASABI\static\js\usage.js -----
import { createUploadTableHTML, renderUploadTableRows } from './common_table.js';

export function initUsageUpload() {
    const usageInput = document.getElementById('usageFileInput');
    if (!usageInput) return;

    usageInput.addEventListener('change', async (e) => {
        const files = e.target.files;
        if (!files.length) return;

        const uploadContainer = document.getElementById('upload-output-container');
        uploadContainer.innerHTML = createUploadTableHTML('upload-output-table');
        const tbody = uploadContainer.querySelector('#upload-output-table tbody');
        tbody.innerHTML = `<tr><td colspan="14" style="text-align:center;">Processing...</td></tr>`;

        window.showLoading();
        try {
            const formData = new FormData();
            for (const file of files) formData.append('file', file);
            
            const res = await fetch('/api/usage/upload', { method: 'POST', body: formData });
            const data = await res.json();
            if (!res.ok) throw new Error(data.message || 'USAGE file processing failed.');
            
            renderUploadTableRows('upload-output-table', data.records);
            window.showNotification('USAGE file processed successfully.', 'success');

        } catch (err) {
            tbody.innerHTML = `<tr><td colspan="14" style="color:red; text-align:center;">Error: ${err.message}</td></tr>`;
            window.showNotification(err.message, 'error');
        } finally {
            window.hideLoading();
            e.target.value = ''; // Reset file input
        }
    });
}

----- C:\Dev\WASABI\static\index.html -----
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>WASABI</title>
    <link rel="stylesheet" href="/static/css/styles.css">
    <link rel="stylesheet" href="/static/css/inout.css">
</head>
<body>

<header id="main-header">
    <button id="inOutViewBtn" class="btn">入庫・出庫</button>
    <button id="datBtn" class="btn">納品・返品 (DAT)</button>
    <button id="usageBtn" class="btn">処方 (USAGE)</button>
    <button id="inventoryBtn" class="btn">棚卸(ファイル)</button>
    <button id="manualInventoryBtn" class="btn">棚卸(手入力)</button>
    <button id="aggregationBtn" class="btn">集計</button>
    <button id="deadStockBtn" class="btn">デッドストック</button>
    <button id="masterEditViewBtn" class="btn">マスター</button>
    <button id="settingsBtn" class="btn">設定</button>
    <button id="reprocessBtn" class="btn">仮登録を再計算</button>
    <button id="exportClientsBtn" class="btn">得意先エクスポート</button>
    <button id="importClientsBtn" class="btn">得意先インポート</button>
    <button id="exportProductsBtn" class="btn">製品エクスポート</button>
    <button id="importProductsBtn" class="btn">製品インポート</button>
</header>

<main>
    <input type="file" id="datFileInput" multiple style="display:none;">
    <input type="file" id="usageFileInput" style="display:none;">
    <input type="file" id="inventoryFileInput" style="display:none;">

    <div id="in-out-view" class="inout-view-container">
        <div class="inout-header-controls">
            <div class="field-group"><label for="in-out-date">日付</label><input type="date" id="in-out-date"></div>
            <div class="field-group"><label for="in-out-type">種別</label><select id="in-out-type"><option>入庫</option><option>出庫</option></select></div>
            <div class="field-group"><label for="in-out-client">得意先</label><select id="in-out-client"></select></div>
            <div class="field-group"><label for="in-out-receipt">伝票番号</label><select id="in-out-receipt"></select></div>
            <div class="buttons-group"><button id="saveBtn" class="btn">保存</button><button id="deleteBtn" class="btn">伝票削除</button></div>
        </div>
        <div class="inout-details-header"><button id="addRowBtn" class="btn">明細を追加</button></div>
        <div id="inout-details-container"></div>
    </div>

    <div id="upload-view" class="hidden">
        <h3 id="upload-view-title">File Upload</h3>
        <div id="upload-output-container"></div>
    </div>
    
    <div id="inventory-view" class="hidden">
        <h3>Inventory File Upload</h3>
        <div id="inventory-output-container"></div>
    </div>

        <div id="manual-inventory-view" class="hidden">
        <h1>棚卸（手入力）</h1>
        <div class="filter-container">
            <div class="field-group">
                <label for="manual-inv-date">棚卸日</label>
                <input type="date" id="manual-inv-date">
            </div>
            <div class="buttons-group">
                <button id="save-manual-inv-btn" class="btn" style="background-color: #0d6efd; color: white;">この内容で棚卸を保存</button>
            </div>
        </div>
        <div id="manual-inventory-container">
            <p>読み込み中...</p>
        </div>
    </div>

    <div id="aggregation-view" class="hidden">
        <div class="filter-container" style="display: flex; flex-wrap: wrap; gap: 10px 16px; align-items: flex-end; margin-bottom: 15px; border: 1px solid #ccc; padding: 10px;">
            <div class="field-group"><label for="startDate">開始日</label><input type="date" id="startDate"></div>
            <div class="field-group"><label for="endDate">終了日</label><input type="date" id="endDate"></div>
            <div class="field-group"><label for="kanaName">カナ名</label><input type="text" id="kanaName" placeholder="（部分一致）"></div>
            <div class="field-group"><label for="dosageForm">剤型</label><input type="text" id="dosageForm" placeholder="（部分一致）"></div>
            <div class="field-group"><label for="reorder-coefficient">発注点係数</label><input type="number" id="reorder-coefficient" value="1.5" step="0.1" style="width: 80px;"></div>
            <div class="field-group">
                <label>薬の種類</label>
                <div style="display: flex; flex-wrap: wrap; gap: 5px 10px;">
                    <label><input type="checkbox" name="drugType" value="poison">毒</label>
                    <label><input type="checkbox" name="drugType" value="deleterious">劇</label>
                    <label><input type="checkbox" name="drugType" value="narcotic">麻</label>
                    <label><input type="checkbox" name="drugType" value="psychotropic1">向1</label>
                    <label><input type="checkbox" name="drugType" value="psychotropic2">向2</label>
                    <label><input type="checkbox" name="drugType" value="psychotropic3">向3</label>
                    <label><input type="checkbox" name="drugType" value="stimulant">覚</label>
                    <label><input type="checkbox" name="drugType" value="stimulant_raw">覚原</label>
                </div>
                </div>
            <div class="field-group"><label><input type="checkbox" id="reorder-needed-filter"> 不足品のみ</label></div>
            <div class="buttons-group" style="margin-left: auto;">
                <button id="run-aggregation-btn" class="btn">集計実行</button>
                <button id="print-aggregation-btn" class="btn">印刷</button>
            </div>
        </div>
        <div id="aggregation-output-container"></div>
    </div>

    <div id="search-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h2>薬品検索</h2>
                <button id="closeModalBtn" class="close-button">&times;</button>
            </div>
            <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                <input type="text" id="product-search-input" placeholder="製品名またはカナ名（2文字以上）" style="flex-grow: 1; padding: 5px;">
                <button id="product-search-btn" class="btn">検索</button>
            </div>
            <div class="modal-body" id="search-results-container">
                <table id="search-results-table">
                    <thead><tr><th>製品名</th><th>メーカー</th><th>包装</th><th>YJコード</th><th>JANコード</th><th>選択</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>

        <div id="master-edit-view" class="hidden">
        <div class="inout-header-controls" style="justify-content: flex-end;">
            <div class="buttons-group">
                <button id="addMasterRowBtn" class="btn">新規行を追加</button>
                <button id="refreshMastersBtn" class="btn">一覧を更新</button>
            </div>
        </div>
        <div id="master-edit-container"></div>
    </div>

    <div id="settings-view" class="hidden">
        <h1>設定</h1>
        <div class="settings-form-container">
            <fieldset>
                <legend>e-mednet 連携設定</legend>
                <div class="field-group">
                    <label for="emednetUserID">ユーザーID</label>
                    <input type="text" id="emednetUserID" style="width: 300px;">
                </div>
                <div class="field-group">
                    <label for="emednetPassword">パスワード</label>
                    <input type="password" id="emednetPassword" style="width: 300px;">
                </div>
            </fieldset>
            
            <div class="buttons-group" style="margin-top: 20px;">
                <button id="saveSettingsBtn" class="btn" style="background-color: #0d6efd; color: white;">設定を保存</button>
            </div>
        </div>
    </div>


    <div id="deadstock-view" class="hidden">
        <h1>デッドストックリスト</h1>
        <div class="filter-container">
            <div class="field-group">
                <label for="ds-startDate">開始日</label>
                <input type="date" id="ds-startDate">
            </div>
            <div class="field-group">
                <label for="ds-endDate">終了日</label>
                <input type="date" id="ds-endDate">
            </div>
            <div class="field-group">
                <label><input type="checkbox" id="ds-exclude-zero-stock"> 在庫が0の品目を除外</label>
            </div>
            <div class="buttons-group">
                <button id="run-dead-stock-btn" class="btn">リスト作成</button>
            </div>
        </div>
        <div id="deadstock-output-container"></div>

    <input type="file" id="importClientsInput" style="display:none;" accept=".csv">
    <input type="file" id="importProductsInput" style="display:none;" accept=".csv">
</main>

<div id="loading-overlay" class="hidden"><div class="spinner"></div><p>Processing...</p></div>
<div id="notification-box" class="notification-box"></div>

<script type="module" src="/static/js/app.js"></script>
</body>
</html>

----- C:\Dev\WASABI\transaction\handler.go -----
package transaction

import (
	"database/sql"
	"encoding/json"
	"net/http"
	"strings"
	"wasabi/db"
)

// GetReceiptsHandler returns a list of receipt numbers for a given date.
func GetReceiptsHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		date := r.URL.Query().Get("date")
		if date == "" {
			http.Error(w, "Date parameter is required", http.StatusBadRequest)
			return
		}
		// Assuming you will add GetReceiptNumbersByDate to db package
		receipts, err := db.GetReceiptNumbersByDate(conn, date)
		if err != nil {
			http.Error(w, "Failed to get receipt numbers", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(receipts)
	}
}

// GetTransactionHandler returns all line items for a given receipt number.
func GetTransactionHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		receiptNumber := strings.TrimPrefix(r.URL.Path, "/api/transaction/")
		if receiptNumber == "" {
			http.Error(w, "Receipt number is required", http.StatusBadRequest)
			return
		}
		records, err := db.GetTransactionsByReceiptNumber(conn, receiptNumber)
		if err != nil {
			http.Error(w, "Failed to get transaction details", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(records)
	}
}

// DeleteTransactionHandler handles the deletion of all records for a given receipt number.
func DeleteTransactionHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		receiptNumber := strings.TrimPrefix(r.URL.Path, "/api/transaction/delete/")
		if receiptNumber == "" {
			http.Error(w, "Receipt number is required", http.StatusBadRequest)
			return
		}
		tx, err := conn.Begin()
		if err != nil {
			http.Error(w, "Failed to start transaction", http.StatusInternalServerError)
			return
		}
		defer tx.Rollback()

		if err := db.DeleteTransactionsByReceiptNumberInTx(tx, receiptNumber); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

		if err := tx.Commit(); err != nil {
			http.Error(w, "Failed to commit transaction", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "Deleted successfully"})
	}
}


----- C:\Dev\WASABI\units\handler.go -----
package units

import (
	"encoding/json"
	"net/http"
)

// GetTaniMapHandlerは、ロード済みの単位マップを返します。
func GetTaniMapHandler() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		if internalMap == nil {
			json.NewEncoder(w).Encode(make(map[string]string))
			return
		}
		json.NewEncoder(w).Encode(internalMap)
	}
}


----- C:\Dev\WASABI\units\units.go -----
package units

import (
	"encoding/csv"
	"fmt"
	"io"
	"os"
	"wasabi/model"

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

var internalMap map[string]string
var reverseMap map[string]string

// FormatPackageSpecは、JCSHMSのデータから仕様通りの包装文字列を生成します。
func FormatPackageSpec(jcshms *model.JCShms) string {
	if jcshms == nil {
		return ""
	}

	yjUnitName := ResolveName(jcshms.JC039)
	pkg := fmt.Sprintf("%s %g%s", jcshms.JC037, jcshms.JC044, yjUnitName)

	if jcshms.JA006.Valid && jcshms.JA008.Valid && jcshms.JA008.Float64 != 0 {
		// ▼▼▼ [修正点] 未使用のyjUnitパラメータを削除 ▼▼▼
		resolveJanUnitName := func(code string) string {
			if code != "0" && code != "" {
				return ResolveName(code)
			}
			return "" // 0か空の場合は単位を省略
		}

		janUnitName := resolveJanUnitName(jcshms.JA007.String)
		// ▲▲▲ 修正ここまで ▲▲▲

		pkg += fmt.Sprintf(" (%g%s×%g%s)",
			jcshms.JA006.Float64,
			yjUnitName,
			jcshms.JA008.Float64,
			janUnitName,
		)
	}
	return pkg
}

// (LoadTANIFile, ResolveName, ResolveCode functions are unchanged)
func LoadTANIFile(path string) (map[string]string, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, fmt.Errorf("LoadTANIFile: open %s: %w", path, err)
	}
	defer file.Close()

	decoder := japanese.ShiftJIS.NewDecoder()
	reader := csv.NewReader(transform.NewReader(file, decoder))
	reader.LazyQuotes = true
	reader.FieldsPerRecord = -1

	m := make(map[string]string)
	for {
		record, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			return nil, fmt.Errorf("LoadTANIFile: read %s: %w", path, err)
		}
		if len(record) < 2 {
			continue
		}
		code := record[0]
		name := record[1]
		m[code] = name
	}
	internalMap = m

	reverseMap = make(map[string]string)
	for code, name := range internalMap {
		reverseMap[name] = code
	}

	return m, nil
}

func ResolveName(code string) string {
	if internalMap == nil {
		return code
	}
	if name, ok := internalMap[code]; ok {
		return name
	}
	return code
}

func ResolveCode(name string) string {
	if reverseMap == nil {
		return ""
	}
	if code, ok := reverseMap[name]; ok {
		return code
	}
	return ""
}


----- C:\Dev\WASABI\usage\handler.go -----
// C:\Dev\WASABI\usage\handler.go

package usage

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"wasabi/db"
	"wasabi/mappers"
	"wasabi/mastermanager"
	"wasabi/model"
	"wasabi/parsers"
)

// insertTransactionQuery defines the SQL statement for inserting transaction records.
const insertTransactionQuery = `
INSERT OR REPLACE INTO transaction_records (
    transaction_date, client_code, receipt_number, line_number, flag,
    jan_code, yj_code, product_name, kana_name, usage_classification, package_form, package_spec, maker_name,
    dat_quantity, jan_pack_inner_qty, jan_quantity, jan_pack_unit_qty, jan_unit_name, jan_unit_code,
    yj_quantity, yj_pack_unit_qty, yj_unit_name, unit_price, purchase_price, supplier_wholesale,
    subtotal, tax_amount, tax_rate, expiry_date, lot_number, flag_poison,
    flag_deleterious, flag_narcotic, flag_psychotropic, flag_stimulant,
    flag_stimulant_raw, process_flag_ma, processing_status
) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)`

// UploadUsageHandler handles the USAGE file upload process.
func UploadUsageHandler(conn *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var originalJournalMode string
		conn.QueryRow("PRAGMA journal_mode").Scan(&originalJournalMode)

		conn.Exec("PRAGMA journal_mode = MEMORY;")
		conn.Exec("PRAGMA synchronous = OFF;")

		defer func() {
			conn.Exec("PRAGMA synchronous = FULL;")
			conn.Exec(fmt.Sprintf("PRAGMA journal_mode = %s;", originalJournalMode))
			log.Println("Database settings restored for USAGE handler.")
		}()

		if err := r.ParseMultipartForm(32 << 20); err != nil {
			http.Error(w, "File upload error: "+err.Error(), http.StatusBadRequest)
			return
		}
		defer r.MultipartForm.RemoveAll()

		var allParsed []model.UnifiedInputRecord
		for _, fh := range r.MultipartForm.File["file"] {
			f, err := fh.Open()
			if err != nil {
				log.Printf("Failed to open file %s: %v", fh.Filename, err)
				continue
			}
			defer f.Close()
			recs, err := parsers.ParseUsage(f)
			if err != nil {
				log.Printf("Failed to parse file %s: %v", fh.Filename, err)
				continue
			}
			allParsed = append(allParsed, recs...)
		}

		filtered := removeUsageDuplicates(allParsed)

		if len(filtered) == 0 {
			w.Header().Set("Content-Type", "application/json; charset=utf-8")
			json.NewEncoder(w).Encode(map[string]interface{}{"records": []model.TransactionRecord{}})
			return
		}

		tx, err := conn.Begin()
		if err != nil {
			log.Printf("Failed to begin transaction for usage: %v", err)
			http.Error(w, "internal server error", http.StatusInternalServerError)
			return
		}

		minDate, maxDate := "99999999", "00000000"
		for _, rec := range filtered {
			if rec.Date < minDate {
				minDate = rec.Date
			}
			if rec.Date > maxDate {
				maxDate = rec.Date
			}
		}
		if err := db.DeleteUsageTransactionsInDateRange(tx, minDate, maxDate); err != nil {
			log.Printf("db.DeleteUsageTransactionsInDateRange error: %v", err)
			tx.Rollback()
			http.Error(w, "internal server error", http.StatusInternalServerError)
			return
		}

		var keyList, janList []string
		keySet, janSet := make(map[string]struct{}), make(map[string]struct{})
		for _, rec := range filtered {
			if rec.JanCode != "" && rec.JanCode != "0000000000000" {
				if _, seen := janSet[rec.JanCode]; !seen {
					janSet[rec.JanCode] = struct{}{}
					janList = append(janList, rec.JanCode)
				}
			}
			key := rec.JanCode
			if key == "" || key == "0000000000000" {
				key = fmt.Sprintf("9999999999999%s", rec.ProductName)
			}
			if _, seen := keySet[key]; !seen {
				keySet[key] = struct{}{}
				keyList = append(keyList, key)
			}
		}

		// ▼▼▼ [修正点] マスター取得をコネクション(conn)ではなくトランザクション(tx)で行う ▼▼▼
		mastersMap, err := db.GetProductMastersByCodesMap(tx, keyList)
		if err != nil {
			tx.Rollback()
			http.Error(w, "Failed to pre-fetch product masters", http.StatusInternalServerError)
			return
		}
		jcshmsMap, err := db.GetJcshmsByCodesMap(tx, janList)
		if err != nil {
			tx.Rollback()
			http.Error(w, "Failed to pre-fetch JCSHMS data", http.StatusInternalServerError)
			return
		}
		// ▲▲▲ 修正ここまで ▲▲▲

		stmt, err := tx.Prepare(insertTransactionQuery)
		if err != nil {
			tx.Rollback()
			http.Error(w, "Failed to prepare statement", http.StatusInternalServerError)
			return
		}
		defer stmt.Close()

		const batchSize = 500
		var finalRecords []model.TransactionRecord

		for i, rec := range filtered {
			ar := model.TransactionRecord{
				TransactionDate: rec.Date, Flag: 3, JanCode: rec.JanCode, YjCode: rec.YjCode,
				ProductName: rec.ProductName, YjQuantity: rec.YjQuantity, YjUnitName: rec.YjUnitName,
			}

			master, err := mastermanager.FindOrCreate(tx, rec.JanCode, rec.ProductName, mastersMap, jcshmsMap)
			if err != nil {
				tx.Rollback()
				http.Error(w, fmt.Sprintf("mastermanager failed for jan %s: %v", rec.JanCode, err), http.StatusInternalServerError)
				return
			}

			mappers.MapProductMasterToTransaction(&ar, master)
			if master.Origin == "JCSHMS" {
				ar.ProcessFlagMA = "COMPLETE"
				ar.ProcessingStatus = sql.NullString{String: "completed", Valid: true}
			} else {
				ar.ProcessFlagMA = "PROVISIONAL"
				ar.ProcessingStatus = sql.NullString{String: "provisional", Valid: true}
			}

			_, err = stmt.Exec(
				ar.TransactionDate, ar.ClientCode, ar.ReceiptNumber, ar.LineNumber, ar.Flag,
				ar.JanCode, ar.YjCode, ar.ProductName, ar.KanaName, ar.UsageClassification, ar.PackageForm, ar.PackageSpec, ar.MakerName,
				ar.DatQuantity, ar.JanPackInnerQty, ar.JanQuantity, ar.JanPackUnitQty, ar.JanUnitName, ar.JanUnitCode,
				ar.YjQuantity, ar.YjPackUnitQty, ar.YjUnitName, ar.UnitPrice, ar.PurchasePrice, ar.SupplierWholesale,
				ar.Subtotal, ar.TaxAmount, ar.TaxRate, ar.ExpiryDate, ar.LotNumber, ar.FlagPoison,
				ar.FlagDeleterious, ar.FlagNarcotic, ar.FlagPsychotropic, ar.FlagStimulant,
				ar.FlagStimulantRaw, ar.ProcessFlagMA, ar.ProcessingStatus,
			)
			if err != nil {
				tx.Rollback()
				http.Error(w, fmt.Sprintf("Failed to insert record for JAN %s: %v", ar.JanCode, err), http.StatusInternalServerError)
				return
			}

			finalRecords = append(finalRecords, ar)

			if (i+1)%batchSize == 0 && i < len(filtered)-1 {
				if err := tx.Commit(); err != nil {
					log.Printf("transaction commit error (batch): %v", err)
					http.Error(w, "internal server error", http.StatusInternalServerError)
					return
				}
				tx, err = conn.Begin()
				if err != nil {
					http.Error(w, "Failed to begin next transaction", http.StatusInternalServerError)
					return
				}
				stmt, err = tx.Prepare(insertTransactionQuery)
				if err != nil {
					tx.Rollback()
					http.Error(w, "Failed to re-prepare statement", http.StatusInternalServerError)
					return
				}
			}
		}

		if err := tx.Commit(); err != nil {
			log.Printf("transaction commit error (final): %v", err)
			http.Error(w, "internal server error", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"records": finalRecords,
		})
	}
}

func removeUsageDuplicates(records []model.UnifiedInputRecord) []model.UnifiedInputRecord {
	seen := make(map[string]struct{})
	var result []model.UnifiedInputRecord
	for _, r := range records {
		key := fmt.Sprintf("%s|%s|%s|%s", r.Date, r.JanCode, r.YjCode, r.ProductName)
		if _, ok := seen[key]; ok {
			continue
		}
		seen[key] = struct{}{}
		result = append(result, r)
	}
	return result
}


----- C:\Dev\WASABI\main.go -----
// C:\Dev\WASABI\main.go

package main

import (
	"database/sql"
	"log"
	"net/http"
	"os/exec"
	"runtime"
	"wasabi/config"   // settingsの前に移動
	"wasabi/settings" // settingsを追加

	_ "github.com/mattn/go-sqlite3"

	"wasabi/aggregation"
	"wasabi/backup"
	"wasabi/dat"
	"wasabi/db"
	"wasabi/deadstock"
	"wasabi/inout"
	"wasabi/inventory"
	"wasabi/loader"
	"wasabi/masteredit"
	"wasabi/medrec" // ▼▼▼ [修正点] 追加 ▼▼▼
	"wasabi/reprocess"
	"wasabi/transaction"
	"wasabi/units"
	"wasabi/usage"
)

func main() {
	conn, err := sql.Open("sqlite3", "./wasabi.db")
	if err != nil {
		log.Fatalf("db open error: %v", err)
	}
	conn.Exec("PRAGMA journal_mode = WAL;")
	conn.Exec("PRAGMA busy_timeout = 5000;")
	// ▼▼▼ [修正点] 接続数を2から1に戻す ▼▼▼
	conn.SetMaxOpenConns(1)
	conn.SetMaxIdleConns(1)
	// ▲▲▲ 修正ここまで ▲▲▲
	defer conn.Close()

	if _, err := config.LoadConfig(); err != nil {
		log.Printf("WARN: Could not load config.json: %v", err)
	}

	if err := loader.InitDatabase(conn); err != nil {
		log.Fatalf("master data initialization failed: %v", err)
	}
	if _, err := units.LoadTANIFile("SOU/TANI.CSV"); err != nil {
		log.Fatalf("tani master init failed: %v", err)
	}
	log.Println("Master data loaded successfully.")

	mux := http.NewServeMux()

	// API Endpoints
	mux.HandleFunc("/api/dat/upload", dat.UploadDatHandler(conn))
	mux.HandleFunc("/api/usage/upload", usage.UploadUsageHandler(conn))
	mux.HandleFunc("/api/inout/save", inout.SaveInOutHandler(conn))
	mux.HandleFunc("/api/inventory/upload", inventory.UploadInventoryHandler(conn))
	// ▼▼▼ [修正点] 手入力棚卸用のAPIを追加 ▼▼▼
	mux.HandleFunc("/api/inventory/list", inventory.ListInventoryProductsHandler(conn))
	mux.HandleFunc("/api/inventory/save_manual", inventory.SaveManualInventoryHandler(conn))
	// ▲▲▲ 修正ここまで ▲▲▲
	mux.HandleFunc("/api/aggregation", aggregation.GetAggregationHandler(conn))
	mux.HandleFunc("/api/clients", db.GetAllClientsHandler(conn))
	mux.HandleFunc("/api/products/search", db.SearchJcshmsByNameHandler(conn))
	mux.HandleFunc("/api/units/map", units.GetTaniMapHandler())
	mux.HandleFunc("/api/receipts", transaction.GetReceiptsHandler(conn))
	mux.HandleFunc("/api/transaction/", transaction.GetTransactionHandler(conn))
	mux.HandleFunc("/api/transaction/delete/", transaction.DeleteTransactionHandler(conn))
	mux.HandleFunc("/api/masters/editable", masteredit.GetEditableMastersHandler(conn))
	mux.HandleFunc("/api/master/update", masteredit.UpdateMasterHandler(conn))
	mux.HandleFunc("/api/clients/export", backup.ExportClientsHandler(conn))
	mux.HandleFunc("/api/clients/import", backup.ImportClientsHandler(conn))
	mux.HandleFunc("/api/products/export", backup.ExportProductsHandler(conn))
	mux.HandleFunc("/api/products/import", backup.ImportProductsHandler(conn))
	mux.HandleFunc("/api/transactions/reprocess", reprocess.ReProcessTransactionsHandler(conn))
	mux.HandleFunc("/api/deadstock/list", deadstock.GetDeadStockHandler(conn))
	mux.HandleFunc("/api/deadstock/save", deadstock.SaveDeadStockHandler(conn))
	mux.HandleFunc("/api/settings/get", settings.GetSettingsHandler(conn))
	mux.HandleFunc("/api/settings/save", settings.SaveSettingsHandler(conn))
	mux.HandleFunc("/api/medrec/download", medrec.DownloadHandler(conn)) // ▼▼▼ [修正点] 追加 ▼▼▼

	// Serve Frontend
	mux.Handle("/static/", http.StripPrefix("/static/", http.FileServer(http.Dir("./static"))))
	mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		http.ServeFile(w, r, "./static/index.html")
	})

	port := ":8080"
	log.Printf("Server starting on http://localhost%s", port)
	go openBrowser("http://localhost" + port)
	if err := http.ListenAndServe(port, mux); err != nil {
		log.Fatalf("server failed to start: %v", err)
	}
}

func openBrowser(url string) {
	var err error
	switch runtime.GOOS {
	case "windows":
		err = exec.Command("rundll32", "url.dll,FileProtocolHandler", url).Start()
	case "darwin":
		err = exec.Command("open", url).Start()
	default: // linux, etc.
		err = exec.Command("xdg-open", url).Start()
	}
	if err != nil {
		log.Printf("failed to open browser: %v", err)
	}
}


----- C:\Dev\WASABI\schema.sql -----
-- 得意先マスターテーブル
CREATE TABLE IF NOT EXISTS client_master (
  client_code TEXT PRIMARY KEY,
  client_name TEXT NOT NULL UNIQUE
);
-- 製品マスタ (WASABIの新しい仕様)
CREATE TABLE IF NOT EXISTS product_master (
    product_code TEXT PRIMARY KEY,
    yj_code TEXT,
    product_name TEXT,
    origin TEXT,
    kana_name TEXT,
    maker_name TEXT,
    usage_classification TEXT, -- JC013 (内外区分)
    package_form TEXT,         -- JC037 (包装)
    package_spec TEXT,
    yj_unit_name TEXT,
    yj_pack_unit_qty REAL,
    flag_poison INTEGER,
    flag_deleterious INTEGER,
    flag_narcotic INTEGER,
    flag_psychotropic INTEGER,
    flag_stimulant INTEGER,
    flag_stimulant_raw INTEGER,
    jan_pack_inner_qty REAL,
    jan_unit_code INTEGER,
    jan_pack_unit_qty REAL,
    nhi_price REAL,
    purchase_price REAL,
    supplier_wholesale TEXT
);
-- トランザクションレコード (最終版)
CREATE TABLE IF NOT EXISTS transaction_records (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  transaction_date TEXT,
  client_code TEXT,
  receipt_number TEXT,
  line_number TEXT,
  flag INTEGER,
  jan_code TEXT,
  yj_code TEXT,
  product_name TEXT,
  kana_name TEXT,
  usage_classification TEXT, -- New
  package_form TEXT,
  package_spec TEXT,
  maker_name TEXT,
  dat_quantity REAL,
  jan_pack_inner_qty REAL,
  jan_quantity REAL,
  jan_pack_unit_qty REAL,
  jan_unit_name TEXT,
  jan_unit_code TEXT,
  yj_quantity REAL,
  yj_pack_unit_qty REAL,
  yj_unit_name TEXT,
  unit_price REAL,
  purchase_price REAL, -- New
  supplier_wholesale TEXT, -- New
  subtotal REAL,
  tax_amount REAL,
  tax_rate REAL,
  expiry_date TEXT,
  lot_number TEXT,
  flag_poison INTEGER,
  flag_deleterious INTEGER,
  flag_narcotic INTEGER,
  flag_psychotropic INTEGER,
  flag_stimulant INTEGER,
  flag_stimulant_raw INTEGER,
  process_flag_ma TEXT,
  processing_status TEXT
);
-- JCSHMSマスタ
CREATE TABLE IF NOT EXISTS jcshms (
  JC000 TEXT, JC001 TEXT, JC002 TEXT, JC003 TEXT, JC004 TEXT, JC005 TEXT, JC006 TEXT, JC007 TEXT, JC008 TEXT, JC009 TEXT,
  JC010 TEXT, JC011 TEXT, JC012 TEXT, JC013 TEXT, JC014 TEXT, JC015 TEXT, JC016 TEXT, JC017 TEXT, JC018 TEXT, JC019 TEXT,
  JC020 TEXT, JC021 TEXT, JC022 TEXT, JC023 TEXT, JC024 TEXT, JC025 TEXT, JC026 TEXT, JC027 TEXT, JC028 TEXT, JC029 TEXT,
  JC030 TEXT, JC031 TEXT, JC032 TEXT, JC033 TEXT, JC034 TEXT, JC035 TEXT, JC036 TEXT, JC037 TEXT, JC038 TEXT, JC039 TEXT,
  JC040 TEXT, JC041 TEXT, JC042 TEXT, JC043 TEXT, JC044 REAL, JC045 TEXT, JC046 TEXT, JC047 TEXT, JC048 TEXT, JC049 TEXT,
  JC050 REAL, JC051 TEXT, JC052 TEXT, JC053 TEXT, JC054 TEXT, JC055 TEXT, JC056 TEXT, JC057 TEXT, JC058 TEXT, JC059 TEXT,
  JC060 TEXT, JC061 INTEGER, JC062 INTEGER, JC063 INTEGER, JC064 INTEGER, JC065 INTEGER, JC066 INTEGER, JC067 TEXT, JC068 TEXT, JC069 TEXT,
  JC070 TEXT, JC071 TEXT, JC072 TEXT, JC073 TEXT, JC074 TEXT, JC075 TEXT, JC076 TEXT, JC077 TEXT, JC078 TEXT, JC079 TEXT,
  JC080 TEXT, JC081 TEXT, JC082 TEXT, JC083 TEXT, JC084 TEXT, JC085 TEXT, JC086 TEXT, JC087 TEXT, JC088 TEXT, JC089 TEXT,
  JC090 TEXT, JC091 TEXT, JC092 TEXT, JC093 TEXT, JC094 TEXT, JC095 TEXT, JC096 TEXT, JC097 TEXT, JC098 TEXT, JC099 TEXT,
  JC100 TEXT, JC101 TEXT, JC102 TEXT, JC103 TEXT, JC104 TEXT, JC105 TEXT, JC106 TEXT, JC107 TEXT, JC108 TEXT, JC109 TEXT,
  JC110 TEXT, JC111 TEXT, JC112 TEXT, JC113 TEXT, JC114 TEXT, JC115 TEXT, JC116 TEXT, JC117 TEXT, JC118 TEXT, JC119 TEXT,
  JC120 TEXT, JC121 TEXT, JC122 TEXT, JC123 TEXT, JC124 TEXT,
  PRIMARY KEY(JC000)
);
-- JANCODEマスタ
CREATE TABLE IF NOT EXISTS jancode (
  JA000 TEXT, JA001 TEXT, JA002 TEXT, JA003 TEXT, JA004 TEXT, JA005 TEXT, JA006 REAL, JA007 TEXT, JA008 REAL, JA009 TEXT,
  JA010 TEXT, JA011 TEXT, JA012 TEXT, JA013 TEXT, JA014 TEXT, JA015 TEXT, JA016 TEXT, JA017 TEXT, JA018 TEXT, JA019 TEXT,
  JA020 TEXT, JA021 TEXT, JA022 TEXT, JA023 TEXT, JA024 TEXT, JA025 TEXT, JA026 TEXT, JA027 TEXT, JA028 TEXT, JA029 TEXT,
  PRIMARY KEY(JA001)
);
-- 自動採番シーケンス
CREATE TABLE IF NOT EXISTS code_sequences (
  name TEXT PRIMARY KEY,
  last_no INTEGER NOT NULL
);
INSERT OR IGNORE INTO code_sequences(name, last_no) VALUES ('MA2Y', 0);
INSERT OR IGNORE INTO code_sequences(name, last_no) VALUES ('CL', 0);

-- ▼▼▼ [修正点] 検索を高速化するためのインデックスを追加 ▼▼▼
CREATE INDEX IF NOT EXISTS idx_transactions_jan_code ON transaction_records (jan_code);
CREATE INDEX IF NOT EXISTS idx_transactions_date ON transaction_records (transaction_date);
CREATE INDEX IF NOT EXISTS idx_transactions_flag ON transaction_records (flag);
CREATE INDEX IF NOT EXISTS idx_product_master_kana_name ON product_master (kana_name);

-- デッドストックリストテーブル
CREATE TABLE IF NOT EXISTS dead_stock_list (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  product_code TEXT NOT NULL,
  yj_code TEXT,
  package_form TEXT,
  jan_pack_inner_qty REAL,
  yj_unit_name TEXT,
  stock_quantity_jan REAL NOT NULL,
  expiry_date TEXT,
  lot_number TEXT,
  created_at TEXT NOT NULL,
  UNIQUE(product_code, expiry_date, lot_number)
);

CREATE INDEX IF NOT EXISTS idx_tx_jan_date
  ON transaction_records(jan_code, transaction_date);

